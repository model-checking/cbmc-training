<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>CBMC</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> CBMC quick start</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="installation.html"><strong aria-hidden="true">1.1.</strong> CBMC installation</a></li><li class="chapter-item expanded "><a href="cbmc/overview/unit-testing.html"><strong aria-hidden="true">1.2.</strong> CBMC as unit testing</a></li><li class="chapter-item expanded "><a href="cbmc/overview/debugging.html"><strong aria-hidden="true">1.3.</strong> CBMC as debugging</a></li><li class="chapter-item expanded "><a href="cbmc/overview/proof.html"><strong aria-hidden="true">1.4.</strong> CBMC as proof</a></li></ol></li><li class="chapter-item expanded "><a href="cbmc/overview/index.html"><strong aria-hidden="true">2.</strong> CBMC proofs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="cbmc/overview/cbmc.html"><strong aria-hidden="true">2.1.</strong> Running cbmc</a></li><li class="chapter-item expanded "><a href="cbmc/overview/loop-unwinding.html"><strong aria-hidden="true">2.2.</strong> Loop unwinding</a></li><li class="chapter-item expanded "><a href="cbmc/overview/checking-properties.html"><strong aria-hidden="true">2.3.</strong> Property checking</a></li><li class="chapter-item expanded "><a href="cbmc/overview/checking-coverage.html"><strong aria-hidden="true">2.4.</strong> Coverage checking</a></li><li class="chapter-item expanded "><a href="cbmc/overview/proof-harnesses.html"><strong aria-hidden="true">2.5.</strong> Proof harnesses</a></li><li class="chapter-item expanded "><a href="cbmc/overview/proof-assumptions.html"><strong aria-hidden="true">2.6.</strong> Proof assumptions</a></li><li class="chapter-item expanded "><a href="cbmc/overview/goto-programs.html"><strong aria-hidden="true">2.7.</strong> Goto programs</a></li></ol></li><li class="chapter-item expanded "><a href="starter-kit/overview/index.html"><strong aria-hidden="true">3.</strong> CBMC proof projects</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> CBMC viewer</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Litani</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Continuous integration</div></li><li class="chapter-item expanded "><a href="faq/index.html"><strong aria-hidden="true">7.</strong> Frequently asked questions</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="faq/cbmc.html"><strong aria-hidden="true">7.1.</strong> How does CBMC work?</a></li><li class="chapter-item expanded "><a href="faq/loop-unwinding.html"><strong aria-hidden="true">7.2.</strong> What is loop unwinding?</a></li><li class="chapter-item expanded "><a href="faq/memory-model.html"><strong aria-hidden="true">7.3.</strong> How do memory pointers work?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.4.</strong> How do function pointers work?</div></li><li class="chapter-item expanded "><a href="faq/malloc.html"><strong aria-hidden="true">7.5.</strong> How does malloc work?</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">7.6.</strong> How do I write a good stub?</div></li><li class="chapter-item expanded "><a href="faq/termination.html"><strong aria-hidden="true">7.7.</strong> What do I do when CBMC won't stop?</a></li></ol></li><li class="chapter-item expanded "><a href="management/index.html"><strong aria-hidden="true">8.</strong> CBMC project management</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="management/Plan-your-proof.html"><strong aria-hidden="true">8.1.</strong> Project planning</a></li><li class="chapter-item expanded "><a href="management/Write-a-good-proof.html"><strong aria-hidden="true">8.2.</strong> Writing a good proof</a></li><li class="chapter-item expanded "><a href="management/Debug-an-error-trace.html"><strong aria-hidden="true">8.3.</strong> Debugging an error trace</a></li><li class="chapter-item expanded "><a href="management/Code-for-verification.html"><strong aria-hidden="true">8.4.</strong> Coding for verification</a></li><li class="chapter-item expanded "><a href="management/Code-review-for-proofs.html"><strong aria-hidden="true">8.5.</strong> Proof evaluation</a></li></ol></li><li class="chapter-item expanded "><a href="projects.html"><strong aria-hidden="true">9.</strong> CBMC projects</a></li><li class="chapter-item expanded "><a href="resources.html"><strong aria-hidden="true">10.</strong> CBMC resources</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">CBMC</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="cbmc-quick-start"><a class="header" href="#cbmc-quick-start">CBMC quick start</a></h1>
<p><a href="https://github.com/diffblue/cbmc">CBMC</a> is a model checker for
C. This means that CBMC will explore all possible paths through your code
on all possible inputs, and will check that all assertions in your code are
true.
CBMC can also check for the possibility of
memory safety errors (like buffer overflow) and for instances of
undefined behavior (like signed integer overflow).
CBMC is a bounded model checker, however, and using CBMC may require
restricting inputs to inputs of some bounded size.
The result is assurance that your code behaves as expected for all
such inputs.</p>
<p>CBMC has been used on
over a dozen <a href="projects.html">industrial software verification projects</a>
as a routine part of software development and continuous integration.
This experience has resulted in some &quot;best practices&quot; for how to
build software for CBMC and how to run CBMC in development.
The <a href="https://github.com/model-checking/cbmc-starter-kit">CBMC starter kit</a>
is an implementation of these best practices,
and is intended to make it easy to deploy CBMC to a software project
as part of software development and continuous integration.</p>
<p>This document is a guide to using CBMC and to deploying CBMC to
an industrial software verification project.</p>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting started</a></h2>
<p>For a quick start on writing proofs that includes simple exercises, read</p>
<ul>
<li><a href="installation.html">CBMC installation</a></li>
<li><a href="cbmc/overview/unit-testing.html">CBMC as unit testing</a></li>
<li><a href="cbmc/overview/introduction.html">CBMC as debugging</a></li>
<li><a href="cbmc/overview">CBMC proofs</a></li>
</ul>
<p>For a quick start on deploying CBMC to a software project,
we recommend that you read our <a href="starter-kit/overview">tutorial</a>, but
if you want to dive right in, you can <a href="installation.html">install the tools</a> and</p>
<ul>
<li>Read <a href="starter-kit/overview#configure-the-repository">configure the repository</a>
to set up a software repository for CBMC proof</li>
<li>Read <a href="starter-kit/overview#configure-the-proof">configure the proof</a>
to add a new CBMC proof to an existing set of CBMC proofs</li>
<li>Read <a href="starter-kit/overview#run-all-the-proofs">run all proofs</a>
to run a set of existing CBMC proofs and examine the results.</li>
</ul>
<p>For advice on planning and managing a CBMC proof project,
read <a href="management">CBMC project management</a>.</p>
<p>To learn more, see our list of <a href="resources.html">CBMC resources</a> and
<a href="projects.html">CBMC projects</a>, and see</p>
<ul>
<li>CBMC starter kit <a href="https://model-checking.github.io/cbmc-starter-kit/reference-manual">reference manual</a> and <a href="https://model-checking.github.io/cbmc-starter-kit">documentation</a></li>
<li>CBMC viewer <a href="https://model-checking.github.io/cbmc-viewer/reference-manual">reference manual</a> and <a href="https://model-checking.github.io/cbmc-viewer">documentation</a></li>
<li>CBMC <a href="http://cprover.diffblue.com/">developer guide</a></li>
<li>Litani <a href="https://awslabs.github.io/aws-build-accumulator">reference manual</a></li>
</ul>
<h2 id="helping-others"><a class="header" href="#helping-others">Helping others</a></h2>
<p>This training material is a work in progress.  If you have suggestions,
corrections, or questions, please contact us by submitting a
<a href="https://github.com/model-checking/cbmc-training/issues">GitHub issue</a>.
If you have some training of your own that you would like to contribute,
please submit your contributions as a
<a href="https://github.com/model-checking/cbmc-training/pulls">GitHub pull request</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-installation"><a class="header" href="#cbmc-installation">CBMC installation</a></h1>
<h2 id="macos"><a class="header" href="#macos">MacOS</a></h2>
<p>On MacOS, we recommend installing with <a href="https://brew.sh/">brew</a>. Install with</p>
<pre><code class="language-bash">brew tap aws/tap
brew install cbmc cbmc-viewer cbmc-starter-kit litani universal-ctags
</code></pre>
<p>The <a href="https://brew.sh/">brew home page</a> gives instructions for
installing <code>brew</code>. The first command taps the AWS repository that
contains some of the brew packages, and the second command installs the
packages. Installing <code>ctags</code> is recommended but optional, see
<a href="installation.html#installation-notes">below</a>.</p>
<h2 id="ubuntu"><a class="header" href="#ubuntu">Ubuntu</a></h2>
<p>On Ubuntu, we recommend installing by downloading the <code>cbmc</code> and <code>litani</code>
installation packages for your operating system from the
<a href="https://github.com/diffblue/cbmc/releases/latest">CBMC release page</a> and the
<a href="https://github.com/awslabs/aws-build-accumulator/releases/latest">Litani release page</a>.
Install with</p>
<pre><code class="language-bash">sudo apt install python3 python3-pip *cbmc*.deb *litani*.deb universal-ctags
python3 -m pip install cbmc-viewer cbmc-starter-kit
</code></pre>
<p>The <a href="https://www.python.org/downloads/">python download page</a>
gives instructions for installing python and pip.
Installing <code>ctags</code> is recommended but optional, see
<a href="installation.html#installation-notes">below</a>. The <code>pip</code> installation packages for
<code>cbmc-viewer</code> and <code>cbmc-starter-kit</code> can be used on any machine with
<code>python3</code> including MacOS.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>On Windows, we recommend using the <a href="https://docs.microsoft.com/en-us/windows/wsl/">Windows Subsystem for Linux</a> (WSL) and using
the Ubuntu instructions above.  CBMC and CBMC viewer
will run natively on Windows, but Litani and the CBMC starter kit
that depends on Litani are not supported on Windows.
To install natively on Windows (without using WSL),
download the Windows installation package from the
<a href="https://github.com/diffblue/cbmc/releases/latest">CBMC release page</a> and
run</p>
<pre><code class="language-bash">python3 -m pip install cbmc-viewer
msiexec /i cbmc*.msi
PATH=&quot;C:\Program Files\cbmc\bin&quot;;%PATH%
</code></pre>
<h2 id="installation-notes"><a class="header" href="#installation-notes">Installation notes</a></h2>
<p>If you have difficulty installing these tools, please let us know
by submitting a
<a href="https://github.com/model-checking/cbmc-training/issues">GitHub issue</a>.</p>
<p>The installation of <code>ctags</code> is optional, but without <code>ctags</code>, <code>cbmc-viewer</code>
will fail to link some symbols appearing in error traces to their
definitions in the source code.
The <a href="https://en.wikipedia.org/wiki/Ctags">ctags</a> tool has a long history.
The original ctags was replaced by
<a href="http://ctags.sourceforge.net/">exuberant ctags</a> which was replaced by
<a href="https://github.com/universal-ctags/ctags">universal ctags</a>.
Any version will work better than none, but we recommend universal ctags.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-as-unit-testing"><a class="header" href="#cbmc-as-unit-testing">CBMC as unit testing</a></h1>
<p>Think of CBMC as a form of unit testing: If you can write a unit test,
then you can write a CBMC proof.  One of the things we can do with
unit testing is to run a function on a set of inputs, and to compare
the result with the expected result.  Think of CBMC as a unit tester
that runs the function on all possible inputs.</p>
<p>Here is a
function <code>quartile</code> from <a href="cbmc/overview/quartile.c">quartile.c</a>
that returns the quartile of an integer between 0 and 99.</p>
<pre><code class="language-c">int quartile(int x) {
  int y;

  if (x &lt; 0 || x &gt; 99) return 0;

  if (x &lt; 50)
    if (x &lt; 25)
      y = 1;
    else
      y = 2;
  else
    if (x &lt; 75)
      y = 3;
    else
      y = 4;

  return y;
}
</code></pre>
<p>Here a unit test from <a href="cbmc/overview/unit-test.c">unit-test.c</a> that tests
<code>quartile</code> using a number from the first quartile.</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
int quartile(int x);

int main() {
  int x = 1;
  int result = quartile(x);
  assert(result == 1);
}
</code></pre>
<p>We can build the unit test with <code>gcc</code> and run it.
When we do, the unit test runs successfully,
and the assertion does not fail:</p>
<pre><code class="language-bash">gcc quartile.c unit-test.c -o unit-test
./unit-test
</code></pre>
<p>We can also build the unit test with <code>goto-cc</code>, which is a drop-in
replacement for <code>gcc</code> that comes with CBMC.  Now we can use CBMC to
run the unit test, and again the assertion does not fail:</p>
<pre><code class="language-bash">goto-cc quartile.c unit-test.c -o unit-test
cbmc ./unit-test
</code></pre>
<pre><code>** Results:
unit-test.c function main
[main.assertion.1] line 8 assertion result == 1: SUCCESS

** 0 of 1 failed (1 iterations)
VERIFICATION SUCCESSFUL
</code></pre>
<p>For examples as simple as this,
we can actually run CBMC directly on the source files
(without explicitly invoking <code>goto-cc</code>):</p>
<pre><code>cbmc quartile.c unit-test.c
</code></pre>
<pre><code>** Results:
unit-test.c function main
[main.assertion.1] line 8 assertion result == 1: SUCCESS

** 0 of 1 failed (1 iterations)
VERIFICATION SUCCESSFUL
</code></pre>
<p>But now we can do something interesting with CBMC.
The unit test currently initializes the variable <code>x</code> to 1,
and CBMC considers 1 to be the initial value of <code>x</code>.  If
we remove the initializer, CBMC allows any integer value to be
the initial value of <code>x</code>. This is a general rule: If CBMC encounters
an uninitialized variable, then CBMC allows any value from the variable's
type to be the variable's initial value.
We say that CBMC treats uninitialized variables as having unconstrained
initial values.</p>
<p>If we rewrite the unit test</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
int quartile(int x);

int main() {
  int x; // The value of x is now any value of type int
  int result = quartile(x);
  assert(result == 1);
}
</code></pre>
<p>and rerun CBMC</p>
<pre><code class="language-bash">cbmc quartile.c unit-test.c
</code></pre>
<pre><code>** Results:
unit-test.c function main
[main.assertion.1] line 8 assertion result == 1: FAILURE

** 1 of 1 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>we can see that the assertion has failed.  We can ask CBMC to produce
an error trace that demonstrates one way in which the assertion can fail</p>
<pre><code class="language-bash">cbmc quartile.c unit-test.c --trace
</code></pre>
<pre><code>** Results:
unit-test.c function main
[main.assertion.1] line 8 assertion result == 1: FAILURE

Trace for main.assertion.1:

State 21 file unit-test.c function main line 6 thread 0
----------------------------------------------------
  x=-2147483547 (10000000 00000000 00000000 01100101)

State 22 file unit-test.c function main line 7 thread 0
----------------------------------------------------
  result=0 (00000000 00000000 00000000 00000000)

State 26 file unit-test.c function main line 7 thread 0
----------------------------------------------------
  x=-2147483547 (10000000 00000000 00000000 01100101)

State 27 file quartile.c function quartile line 2 thread 0
----------------------------------------------------
  y=0 (00000000 00000000 00000000 00000000)

State 33 file unit-test.c function main line 7 thread 0
----------------------------------------------------
  result=0 (00000000 00000000 00000000 00000000)

Violated property:
  file unit-test.c function main line 8 thread 0
  assertion result == 1
  !((signed long int)(signed long int)!(result == 1) != 0l)

** 1 of 1 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>and we see that in the first step of this error trace the variable <code>x</code>
is initialized to the integer value <code>x=-2147483547</code>.</p>
<p>Well, that's not quite what we intended, but we don't expect <code>quartile</code>
to return 1 on every integer, just on integers in the first quartile.
We can constrain <code>x</code> to be an integer in the first quartile by adding
an assumption to the unit test:</p>
<pre><code class="language-c">#include &lt;assert.h&gt;
int quartile(int x);

int main() {
  int x;
  __CPROVER_assume(0 &lt;= x &amp;&amp; x &lt; 25);    // this is a precondition
  int result = quartile(x);
  assert(result == 1);                   // this is a postcondition
}
</code></pre>
<p>Rerunning CBMC, we see that the assertion is always true:</p>
<pre><code class="language-bash">cbmc quartile.c unit-test.c
</code></pre>
<pre><code>** Results:
unit-test.c function main
[main.assertion.1] line 9 assertion result == 1: SUCCESS

** 0 of 1 failed (1 iterations)
VERIFICATION SUCCESSFUL
</code></pre>
<p>Let's pause for a moment to notice that we have already done something
interesting.
We have proved that the function <code>quartile</code> returns 1 when it is called
on any integer in the first quartile.
We have partially specified the behavior of the function using
a precondition (the assumption that <code>x</code> is in the first quartile)
and a postcondition (the assertion that the return value is <code>1</code>).
If the function is called with an input that satisfies the precondition,
then the function returns with a value that satisfies the postcondition.
Of course, we have only partially specified the behavior of the function.
What happens when it is called with an integer in the second
quartile?  The specification doesn't say.  But we have taken
the first step toward specification and verification of our function.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-as-debugging"><a class="header" href="#cbmc-as-debugging">CBMC as debugging</a></h1>
<p>Think of CBMC as a form of debugging: CBMC does an exhaustive search for
issues affecting functional correctness and memory safety.  Let's look
at a few examples of the kinds of things that CBMC can find.</p>
<h2 id="memory-safety"><a class="header" href="#memory-safety">Memory safety</a></h2>
<p>The source code in <a href="cbmc/overview/examples/simple/memory-safety.c">memory-safety.c</a></p>
<pre><code class="language-c">#define SIZE 20
char buffer[SIZE];

char read_buffer(int i)  { return buffer[i];     }
char read_pointer(int i) { return *(buffer + i); }

int main() {
  int index;
  read_buffer(index);
  read_pointer(index);
}
</code></pre>
<p>allocates a buffer of 20 characters and defines two functions that return
a character from the buffer.  The first function <code>read_buffer</code> uses array
indexing to access the character.  The second function <code>read_pointer</code> uses
pointer dereferencing.  Neither function does any bounds checking.
The <code>main</code> function declares an integer-valued
<code>index</code> and invokes the two functions to access the character at this index.
The fact that index
is uninitialized is significant to CBMC: When CBMC sees an uninitialized
variable, it considers as possible values for that variable all values a
variable of that type can assume.</p>
<p>If you ask CBMC to check buffer accesses,</p>
<pre><code class="language-bash">cbmc memory-safety.c --bounds-check
</code></pre>
<p>CBMC reports violations of both
the lower and upper bounds of the array (because <code>index</code> can assume both
negative and positive values):</p>
<pre><code>line 3 array 'buffer' lower bound in buffer[(signed long int)i]: FAILURE
line 3 array 'buffer' upper bound in buffer[(signed long int)i]: FAILURE
</code></pre>
<p>If you ask CBMC to check pointer dereferencing,</p>
<pre><code class="language-bash">cbmc memory-safety.c --pointer-check
</code></pre>
<p>CBMC reports that the pointer
can point outside the bounds of the buffer:</p>
<pre><code>line 4 dereference failure:
  pointer outside object bounds in buffer[(signed long int)i]: FAILURE
</code></pre>
<p>If you ask CBMC to produce an error trace,</p>
<pre><code class="language-bash">cbmc memory-safety.c --pointer-check  --trace
</code></pre>
<p>you get a step-by-step execution of the program leading to the error, and
the trace ends with the following steps:</p>
<pre><code>State 42 file memory-safety.c function main line 7 thread 0
----------------------------------------------------
  index=21 (00000000 00000000 00000000 00010101)

State 45 file memory-safety.c function main line 8 thread 0
----------------------------------------------------
  i=21 (00000000 00000000 00000000 00010101)

State 49 file memory-safety.c function main line 9 thread 0
----------------------------------------------------
  i=21 (00000000 00000000 00000000 00010101)

Violated property:
  file memory-safety.c function read_pointer line 4 thread 0
  dereference failure: pointer outside object bounds in buffer[(signed long int)i]
  (signed long int)i &gt;= 0l &amp;&amp; !((unsigned long int)(signed long int)i + 1ul &gt;= 21ul)
</code></pre>
<p>CBMC is saying in step 42 that if you choose the value 21 for the <code>index</code>,
then <code>*(buffer + index)</code> points to a location outside the 20-character
buffer.</p>
<h2 id="termination"><a class="header" href="#termination">Termination</a></h2>
<p>The source code in <a href="cbmc/overview/examples/simple/termination.c">termination.c</a></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
int main() {
  size_t initial_size;
  size_t requested_size;

  size_t size = initial_size;
  while (size &lt; requested_size) {
    size *= 2;
  }
}
</code></pre>
<p>illustrates a bug found with CBMC that actually required some
unexpected code changes.
This example reduces the problem to a single loop from an allocator,
and makes the mistake more obvious than it was in the original code.
The allocator begins with an initial
(recommended) size for chunk allocation,
and repeatedly doubles this size until it is large
enough to hold the requested size.  Each iteration of the loop doubles
the size (shifts the size left by one bit) until the size overflows
to 0.  Once the size is 0, doubling the size results in 0, and the loop
never ends.</p>
<p>How would you find this with CBMC (without already knowing the problem exists)?
If you run simply CBMC with</p>
<pre><code class="language-bash">cbmc termination.c
</code></pre>
<p>CBMC will go on forever unwinding the loop forever because it cannot easily
tell from the source code how many times the loop iterates.</p>
<p>You can coach CBMC to unwind the loop just four times with the <code>--unwind</code> flag</p>
<pre><code class="language-bash">cbmc termination.c --unwind 4
</code></pre>
<p>and CBMC terminates with apparent success:</p>
<pre><code>VERIFICATION SUCCESSFUL
</code></pre>
<p>But how do you know that unwinding the loop 4 times is enough?  What if
something bad happens on the 5th iteration and you just never asked
CBMC to look beyond the 4th iteration?</p>
<p>CBMC has a solution. We always run CBMC with an extra flag</p>
<pre><code class="language-bash">cbmc termination.c --unwind 4  --unwinding-assertions
</code></pre>
<p>that checks that loops have been completely unwound: It checks
that the loop termination condition is true after the
loop unwinding.  If you run CBMC with this flag, CBMC reports failure
(the loop unwinding assertion has failed):</p>
<pre><code>line 7 unwinding assertion loop 0: FAILURE
</code></pre>
<p>Try unwinding 40 times:</p>
<pre><code class="language-c">cbmc termination.c --unwind 40  --unwinding-assertions
</code></pre>
<pre><code>line 7 unwinding assertion loop 0: FAILURE
</code></pre>
<p>Try unwinding 80 times:</p>
<pre><code class="language-c">cbmc termination.c --unwind 80  --unwinding-assertions
</code></pre>
<pre><code>line 7 unwinding assertion loop 0: FAILURE
</code></pre>
<p>Try asking for a trace:</p>
<pre><code>cbmc termination.c --unwind 80  --unwinding-assertions --trace
</code></pre>
<p>Now you see that <code>size</code> is stuck at 0.  The final steps of
the trace are</p>
<pre><code>State 257 file termination.c function main line 8 thread 0
----------------------------------------------------
  size=0ul (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

State 260 file termination.c function main line 8 thread 0
----------------------------------------------------
  size=0ul (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

State 263 file termination.c function main line 8 thread 0
----------------------------------------------------
  size=0ul (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

Violated property:
  file termination.c function main line 7 thread 0
  unwinding assertion loop 0

</code></pre>
<p>Try unwinding 64 times since you probably have a 64-bit machine:</p>
<pre><code>cbmc termination.c --unwind 64 --unwinding-assertions --trace
</code></pre>
<p>In the final two steps of the trace you can see the overflow
from a large integer to 0:</p>
<pre><code>State 212 file termination.c function main line 8 thread 0
----------------------------------------------------
  size=9223372036854775808ul (10000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

State 215 file termination.c function main line 8 thread 0
----------------------------------------------------
  size=0ul (00000000 00000000 00000000 00000000 00000000 00000000 00000000 00000000)

Violated property:
  file termination.c function main line 7 thread 0
  unwinding assertion loop 0



** 1 of 1 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-as-proof"><a class="header" href="#cbmc-as-proof">CBMC as proof</a></h1>
<p>Think of CBMC as a tool for doing mathematical proof. CBMC does an
exhaustive search for issues affecting functional correctness and
memory safety.  If CBMC finds an issue, <a href="cbmc/overview/debugging.html">as we have seen</a>,
then CBMC has likely found a bug.
But if CBMC does <em>not</em> find any issues, then you can rest assured
that the issues like memory safety that you are asking CBMC to check for
will not occur in your program with the inputs you are asking CBMC to check.</p>
<p>We note, however, that using CBMC may require bounding the size of the inputs
you are asking CBMC to check.
It may be necessary, for example, to assume that packets
coming off the network are of size at most 1024 bytes
in order to fit the problem into CBMC.
We refer to assumptions like this as <em>proof assumptions</em>.
It is important to remember that proof assumptions exists,
and to communicate them clearly to the reader or consumer of
any proof you write with CBMC.</p>
<p>Let's look again at <a href="cbmc/overview/examples/simple/memory-safety.c">memory-safety.c</a></p>
<pre><code class="language-c">#define SIZE 20
char buffer[SIZE];

char read_buffer(int i)  { return buffer[i];     }
char read_pointer(int i) { return *(buffer + i); }

int main() {
  int index;
  read_buffer(index);
  read_pointer(index);
}
</code></pre>
<p>that we found to have <a href="cbmc/overview/debugging.html#memory-safety">memory safety issues</a>
in the last section.  The problem was obviously the lack of bounds checking
in the code.  Let's fix that.</p>
<h2 id="memory-safety-proof"><a class="header" href="#memory-safety-proof">Memory safety proof</a></h2>
<p>Let's try adding bounds checking.
Consider <a href="cbmc/overview/examples/simple/memory-safety1.c">memory-safety1.c</a></p>
<pre><code class="language-c">#define SIZE 20
char buffer[SIZE];

char read_buffer(int i)  {
  if (i &lt; SIZE) return buffer[i];
  return '\0';
}
char read_pointer(int i) {
  if (i &lt; SIZE) return *(buffer + i);
  return '\0';
}

int main() {
  int index;
  read_buffer(index);
  read_pointer(index);
}
</code></pre>
<p>We probably want better error handling than just returning <code>NULL</code>,
but let's run CBMC to prove memory safety:</p>
<pre><code class="language-bash">cbmc memory-safety1.c --bounds-check --pointer-check
</code></pre>
<pre><code>** Results:
memory-safety1.c function read_buffer
[read_buffer.array_bounds.1] line 10
  array 'buffer' lower bound in buffer[(signed long int)i]: FAILURE
[read_buffer.array_bounds.2] line 10
  array 'buffer' upper bound in buffer[(signed long int)i]: SUCCESS

memory-safety1.c function read_pointer
[read_pointer.pointer_dereference.1] line 14
  dereference failure: pointer outside object bounds in buffer[(signed long int)i]:
  FAILURE

** 2 of 3 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>Oh, nuts.  We failed.  We added bounds checking only for the upper bound.</p>
<h2 id="memory-safety-proof-20"><a class="header" href="#memory-safety-proof-20">Memory safety proof 2.0</a></h2>
<p>Let's try adding bounds checking for both the upper and lower bounds.
Consider <a href="cbmc/overview/examples/simple/memory-safety2.c">memory-safety2.c</a></p>
<pre><code class="language-c">#define SIZE 20
char buffer[SIZE];

char read_buffer(int i)  {
  if (0 &lt;= i &amp;&amp; i &lt; SIZE) return buffer[i];
  return '\0';
}
char read_pointer(int i) {
  if (0 &lt;= i &amp;&amp; i &lt; SIZE) return *(buffer + i);
  return '\0';
}

int main() {
  int index;
  read_buffer(index);
  read_pointer(index);
}
</code></pre>
<p>and run CBMC</p>
<pre><code class="language-bash">cbmc memory-safety2.c --bounds-check --pointer-check
</code></pre>
<pre><code>** 0 of 3 failed (1 iterations)
VERIFICATION SUCCESSFUL
</code></pre>
<p>and declare victory.</p>
<h2 id="memory-safety-proof-harness"><a class="header" href="#memory-safety-proof-harness">Memory safety proof harness</a></h2>
<p>Let's pivot back to the notion of a proof harness before we declare
complete victory.</p>
<p>Back when we introduced <a href="cbmc/overview/unit-testing.html">CBMC as a form of unit testing</a>,
we had a function <a href="cbmc/overview/quartile.c">quartile</a> under test
and a <a href="cbmc/overview/unit-test.c">unit test</a> for <code>quartile</code>.
The unit test set up the software environment for the function under test
and invoked the function.
The function <code>quartile</code> was so simple that all the unit test had to do
was initialize the argument <code>x</code> passed to <code>quartile</code> and invoke
<code>quartile</code> on <code>x</code>.
Then we removed the initialization of <code>x</code> so that CBMC could consider
all possible integer values for the argument <code>x</code>.
We transformed the unit test into what we call a <em>proof harness</em> for
the function <code>quartile</code> and used that with CBMC.</p>
<p>We routinely find ourselves with a library and wanting to use
CBMC to prove that all of the public entry points in the library's
API are memory safe.
Our style is to write a memory safety proof for each entry point
independently.
We write one proof harness for each entry point.  The purpose
of the proof harness is to model the software environment in which
the entry point will be called.  The proof harness will always have
to model the inputs to the entry point.  But the proof harness might
also have to model some aspects of the global state if, for example,
there is a system table accessed by the entry point.</p>
<p>In the ideal world,
a proof harness will construct arbitrary, unconstrained values for
every variable and data structure in the software environment of an
entry point, and invoke the entry point.
In the real world,
the entry point makes some assumptions about its inputs.
It may, at the very least, assume that the system table is well-formed
in the sense that it satisfies some data structure invariant.
In the ideal world, the proof author will talk with the code author
and convince the developer to write more bullet-proof code.
In the real world,
the proof author will model these assumptions in the proof harness
to prove memory safety.
But now these assumptions become part of the proof:
CBMC has demonstrated that the entry point is memory safe,
but only when the assumptions described in the proof harness are true when
the entry point is invoked.
A developer might want to include in the testing framework some
checks that these assumptions really are true at all call sites calling
the entry point.
Or a developer might want to use CBMC to prove this...</p>
<p>But let's return to our memory safety example and transform it into
something you are more likely to encounter in the real world.</p>
<h3 id="the-library"><a class="header" href="#the-library">The library</a></h3>
<p>First, the buffer and the accessor functions are likely to
be part of a library.
Here is <a href="cbmc/overview/examples/simple/library.h">library.h</a></p>
<pre><code class="language-c">char read_buffer(int i);
char read_pointer(int i);
</code></pre>
<p>and <a href="cbmc/overview/examples/simple/library.c">library.c</a></p>
<pre><code class="language-c">#include &quot;library.h&quot;

#define SIZE 20
char buffer[SIZE];

char read_buffer(int i)  {
  if (0 &lt;= i &amp;&amp; i &lt; SIZE) return buffer[i];
  return '\0';
}
char read_pointer(int i) {
  if (0 &lt;= i &amp;&amp; i &lt; SIZE) return *(buffer + i);
  return '\0';
}
</code></pre>
<h3 id="the-proof-harnesses"><a class="header" href="#the-proof-harnesses">The proof harnesses</a></h3>
<p>Second, we write one proof harness for each entry point.
Here is <a href="cbmc/overview/examples/simple/read_buffer_harness.c">read_buffer_harness.c</a></p>
<pre><code class="language-c">#include &quot;library.h&quot;

harness() {
  int index;
  read_buffer(index);
}
</code></pre>
<p>and <a href="cbmc/overview/examples/simple/read_pointer_harness.c">read_pointer_harness.c</a></p>
<pre><code class="language-c">#include &quot;library.h&quot;

harness() {
  int index;
  read_pointer(index);
}
</code></pre>
<p>Notice that we have changed the function name from <code>main</code> to <code>harness</code> in
these proof harnesses.  This is not essential, it is just a matter of style,
but it does avoid name conflicts with a real <code>main</code> that might exist in
the real environment.</p>
<h3 id="the-proof"><a class="header" href="#the-proof">The proof</a></h3>
<p>Now we can run the proofs just as before, giving both the library
and the proof harness on the command line, and also indicating to CBMC
that the function to test is now called <code>harness</code> and not <code>main</code>:</p>
<pre><code class="language-bash">cbmc library.c read_buffer_harness.c --bounds-check --pointer-check --function harness
cbmc library.c read_pointer_harness.c --bounds-check --pointer-check --function harness
</code></pre>
<p>In both cases:</p>
<pre><code>** 0 of 3 failed (1 iterations)
VERIFICATION SUCCESSFUL
</code></pre>
<p>Success!!</p>
<h3 id="building-code-for-proof"><a class="header" href="#building-code-for-proof">Building code for proof</a></h3>
<p>One last thing.
In the real world, the library is not this simple.
There is probably a build process to compile the source code into a library
using a compiler like <code>gcc</code>.</p>
<p>One approach is to build the library using <code>goto-cc</code> in place of <code>gcc</code>.
The compiler <code>goto-cc</code> is intended to be a drop-in replacement for <code>gcc</code>.
Using <code>goto-cc</code> should be as easy as building with <code>CC=goto-cc</code> in place
of <code>CC=gcc</code>.
The difference is that <code>goto-cc</code> produces an intermediate representation for
the program called
a &quot;goto program&quot; or &quot;goto binary&quot; that is used by CBMC for model checking.
When we run <code>cbmc</code>
directly on a source file, CBMC is invoking <code>goto-cc</code> on the source file
before model checking, but we can run <code>goto-cc</code> ourselves to build the
goto program, and run CBMC on that.</p>
<p>Our approach, however, is not to build the entire library.  There are
performance and complexity issues that we won't go into here related to
symbolic execution and constraint solving.
We usually build only the portions of the library that are required to
prove that a particular entry point is memory safe.</p>
<p>Using our simple library above to illustrate, we would build and prove
memory safe the entry point <code>read_buffer</code> as follows:</p>
<pre><code class="language-bash">goto-cc library.c -o library.goto
goto-cc read_buffer_harness.c -o read_buffer_harness.goto
goto-cc library.goto read_buffer_harness.goto -o read_buffer.goto --function harness
cbmc read_buffer.goto --bounds-check --pointer-check
</code></pre>
<p>The first two lines build the source files, the third links them
together (and identifies <code>harness</code> as the entry point), and the fourth line
runs CBMC on the result.  The process for <code>read_pointer</code> is similar.</p>
<p>Now, finally, and forever:</p>
<pre><code>** 0 of 3 failed (1 iterations)
VERIFICATION SUCCESSFUL
</code></pre>
<p>Success!!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-proofs"><a class="header" href="#cbmc-proofs">CBMC proofs</a></h1>
<p>This chapter goes into greater detail on how to use CBMC on
more realistic examples.</p>
<p>We assume that you are familiar with using CBMC
on <a href="cbmc/overview/debugging.html">simple examples</a>.
We assume you have <a href="cbmc/overview/../../installation.html">installed the tools</a>
and have <a href="cbmc/overview/proof.html">read about proof</a> enough to have passing familiarity
with proof, proof harnesses, and building code for proof with CBMC.</p>
<ul>
<li><a href="cbmc/overview/cbmc.html">Running cbmc</a></li>
<li><a href="cbmc/overview/loop-unwinding.html">Loop unwinding</a></li>
<li><a href="cbmc/overview/checking-properties.html">Property checking</a></li>
<li><a href="cbmc/overview/checking-coverage.html">Coverage checking</a></li>
<li><a href="cbmc/overview/proof-harnesses.html">Proof harnesses</a></li>
<li><a href="cbmc/overview/proof-assumptions.html">Proof assumptions</a></li>
<li><a href="cbmc/overview/goto-programs.html">Goto programs</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-cbmc"><a class="header" href="#running-cbmc">Running cbmc</a></h1>
<p>At this point we already have some experience with running CBMC
on simple source files.  For example, we have used CBMC to
find <a href="cbmc/overview/debugging.html#memory-safety">memory safety issues</a>
and debug a <a href="cbmc/overview/debugging.html#termination">termination issue</a>.</p>
<p>One thing we have touched on only lightly is how to interpret the
output of CBMC.  Let's do that now.</p>
<p>Consider the following program <a href="cbmc/overview/examples/vector.c">vector.c</a></p>
<pre><code class="language-c">#include &lt;stdlib.h&gt;
#define LENGTH 2

void init(int *, size_t);

int main() {
  int vector[LENGTH];

  init(vector, LENGTH);
  for (int i=0; i&lt;=LENGTH; i++)
    vector[i] = vector[i] + 1;

  return 0;
}
</code></pre>
<p>Suppose we run CBMC on this program and ask CBMC to do array bounds checking
and to produce an error trace for every array bounds violation that it finds.</p>
<pre><code class="language-bash">cbmc vector.c --bounds-check --trace
</code></pre>
<p>Let's examine the output of CBMC one section at a time.
After some preliminary output, CBMC begins with</p>
<pre><code>Starting Bounded Model Checking
**** WARNING: no body for function init
Unwinding loop main.0 iteration 1 file vector.c line 13 function main thread 0
Unwinding loop main.0 iteration 2 file vector.c line 13 function main thread 0
Unwinding loop main.0 iteration 3 file vector.c line 13 function main thread 0
</code></pre>
<p>CBMC is warning us that it found no function body for <code>init</code>.
We included the function declaration but forgot to include the function
definition.  CBMC treats a function like <code>init</code> with no function body as
a function with no side effects (<code>init</code> will not initialize the vector)
that returns an unconstrained return value (though <code>init</code> returns no value
since the return type is <code>void</code>).</p>
<p>CBMC is also telling us that it unwound the for loop three times.
This makes sense since the array has <code>LENGTH=2</code>.  Notice that CBMC
gave this first (and only) loop in the function <code>main</code> the loop name <code>main.0</code>.</p>
<p>After some logging output (describing the sequence of transformations
CBMC performs on the program to turn it into a Boolean constraint problem
and the invocation of the SAT solver to solve the constraint problem),
CBMC prints its results.</p>
<pre><code>** Results:
vector.c function main
[main.array_bounds.1] line 14
  array 'vector' lower bound in vector[(signed long int)i]: SUCCESS
[main.array_bounds.2] line 14
  array 'vector' upper bound in vector[(signed long int)i]: FAILURE
</code></pre>
<p>CBMC is reporting that it performed two array bounds check on line 14:
it checked whether the lower bound of <code>vector</code> could be violated, and whether
the upper bound could be violated. The lower bound check succeeded and the
upper bound check failed.</p>
<p>Finally, CBMC prints a complete error trace for each check that failed.
In our case, it was the second array bounds check in the function <code>main</code>
that failed, and CBMC gave that check the name <code>main.array_bounds.2</code>.</p>
<pre><code>Trace for main.array_bounds.2:

State 21 file vector.c function main line 10 thread 0
----------------------------------------------------
  vector={ 2760991, 33628711 } ({ 00000000 00101010 00100001 00011111, 00000010 00000001 00100010 00100111 })

State 26 file vector.c function main line 13 thread 0
----------------------------------------------------
  i=0 (00000000 00000000 00000000 00000000)

State 28 file vector.c function main line 14 thread 0
----------------------------------------------------
  vector[0l]=2760992 (00000000 00101010 00100001 00100000)

State 29 file vector.c function main line 13 thread 0
----------------------------------------------------
  i=1 (00000000 00000000 00000000 00000001)

State 32 file vector.c function main line 14 thread 0
----------------------------------------------------
  vector[1l]=33628712 (00000010 00000001 00100010 00101000)

State 33 file vector.c function main line 13 thread 0
----------------------------------------------------
  i=2 (00000000 00000000 00000000 00000010)

Violated property:
  file vector.c function main line 14 thread 0
  array 'vector' upper bound in vector[(signed long int)i]
  !((signed long int)i &gt;= 2l)

</code></pre>
<p>The trace is a step-by-step execution of the program from an initial
state to the array bounds violation.  The trace has six steps.
The steps are numbered
21 through 33 because there were a lot of CBMC internal steps like
initialization of CBMC internal variables that CBMC did not include
in the program trace.  The steps included in the trace
are all assignments to program variables made during the execution.</p>
<p>The first step shows the initialization of <code>vector</code>.  CBMC chose
two fairly large integers as the initial values of the two
integers in the array.  Notice that CBMC is printing the values in
both decimal and binary notation.</p>
<p>The next four steps show the variable assignments made during
the first two iterations of the loop: each iteration does
one assignment to <code>i</code> and one assignment to <code>vector</code>.</p>
<p>The final two steps show the assignment <code>i=2</code> and the attempt to
access <code>vector[i]</code> with <code>i==2</code> that caused the array bounds violation.</p>
<p><a href="https://github.com/model-checking/cbmc-viewer">CBMC viewer</a> is a tool
that summarizes the findings of CBMC in the form of a report that can
be opened in any web browser.  One thing that viewer does is render
the list of findings together with links to the error traces demonstrating
the findings.  Each step of an error trace is linked back to the line of
source code that is responsible for the step, making it easier to follow
the trace and debug the issue.  See the
<a href="https://github.com/model-checking/cbmc-viewer/releases/latest">release page</a>
and the
<a href="https://model-checking.github.io/cbmc-viewer/">documentation</a>
for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="loop-unwinding"><a class="header" href="#loop-unwinding">Loop unwinding</a></h1>
<p>CBMC is a <em>bounded</em> model checker for C.
CBMC works by unwinding the loops in our code
(by inlining a finite number of iterations of the loop).
CBMC needs to know a bound on the number of times it is expected to
unwind any particular loop in our code.
In the same way, CBMC needs to know a bound on the number of times
to invoke any recursive function in our code.</p>
<p>Sometimes CBMC can figure this out on its own.
Consider the program <a href="cbmc/overview/examples/assertions/loop1.c">loop1.c</a></p>
<pre><code class="language-c">#include&lt;assert.h&gt;

int main() {
  unsigned array[10];

  for (int i = 0; i &lt; 10; i++) {
    array[i] = 0;
  }

  for (int i = 0; i &lt; 10; i++) {
    assert(array[i] == 0);
  }
  return 0;
}
</code></pre>
<p>and run CBMC with</p>
<pre><code class="language-bash">cbmc loop1.c
</code></pre>
<p>and CBMC will print</p>
<pre><code class="language-bash">[main.assertion.1] line 11 assertion array[i] == 0: SUCCESS
VERIFICATION SUCCESSFUL
</code></pre>
<p>Sometimes CBMC needs help.  Consider the program <a href="cbmc/overview/examples/assertions/loop2.c">loop2.c</a></p>
<pre><code class="language-c">#include&lt;assert.h&gt;

int main() {
  unsigned bound;
  unsigned array[bound];

  for (int i = 0; i &lt; bound; i++) {
    array[i] = 0;
  }

  for (int i = 0; i &lt; bound; i++) {
    assert(array[i] == 0);
  }
  return 0;
}
</code></pre>
<p>and run CBMC with</p>
<pre><code class="language-bash">cbmc loop2.c
</code></pre>
<p>and CBMC will unwind the first loop until it runs out of resources
or the loop index wraps around.
We need to tell CBMC how
many times to unwind the loops in the program.
Run CBMC with</p>
<pre><code class="language-bash">cbmc --unwind 11 loop2.c
</code></pre>
<p>and CBMC will unwind every loop in the program 10 times (not 11 times!) and
print</p>
<pre><code class="language-bash">[main.assertion.1] line 11 assertion array[i] == 0: SUCCESS
VERIFICATION SUCCESSFUL
</code></pre>
<p>In summary, we use the flag <code>--unwind</code> to tell CBMC to bound the
unwinding of loops in the program.  We use <code>--unwind 11</code> to bound loop
unwinding to 11 iterations.  We can use the flag <code>--unwindset</code> to give
different bounds to different loops.  CBMC names the loops in a
program with the name of the function containing the loop and the
position of the loop within the function.  We can ask CBMC to
display loop names with the <code>--show-loops</code> flag</p>
<pre><code>cbmc --show-loops loop2.c
</code></pre>
<p>and see that the two loops in <code>loop2.c</code> are named <code>main.0</code> and <code>main.1</code>.
We can run CBMC with</p>
<pre><code>cbmc --unwindset main.0:11 --unwindset main.1:11 loop2.c
</code></pre>
<p>and get the same successful verification result as with <code>--unwind 11</code>.
The flags <code>--unwind</code> and
<code>--unwindset</code> can be used together and with different bounds.
CBMC will use the <code>--unwind</code> bound
by default and use the <code>--unwindset</code> bound for the loop it names.</p>
<h2 id="loop-unwinding-assertions"><a class="header" href="#loop-unwinding-assertions">Loop unwinding assertions</a></h2>
<p>Now, however, we have a problem.  CBMC has proved that there is no assertion
failure in the program as long as we limit loops to 10 iterations.  But
how do we know that 10 iterations is enough?  What if it is possible for a
loop to iterate 11 times, and the error we are looking for occurs on the
11th iteration, and we missed it?</p>
<p>CBMC has a solution for this called <em>loop unwinding assertions</em>.
We can ask CBMC to insert loop unwinding assertions with the flag
<code>--unwinding-assertions</code>.
Now, after CBMC has unrolled a loop, it will insert immediately after the
unrolled loop an assertion that the loop termination is true.  In other words,
CBMC will check that it has completely unrolled the loop.
For example, running
CBMC on the first program <a href="cbmc/overview/examples/assertions/loop1.c">loop1.c</a> with</p>
<pre><code class="language-bash">cbmc --unwind 11 --unwinding-assertions loop1.c
</code></pre>
<p>succeeds with</p>
<pre><code class="language-bash">VERIFICATION SUCCESSFUL
</code></pre>
<p>but running CBMC on the second program <a href="cbmc/overview/examples/assertions/loop2.c">loop2.c</a> with</p>
<pre><code class="language-bash">cbmc --unwind 11 --unwinding-assertions loop2.c
</code></pre>
<p>fails with output that includes</p>
<pre><code class="language-bash">[main.unwind.0] line 7 unwinding assertion loop 0: FAILURE
VERIFICATION FAILED
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="property-checking"><a class="header" href="#property-checking">Property checking</a></h1>
<p>CBMC can check more than just assertions in the code.
In this section, we describe properties like memory safety that we
check for every time we run CBMC.
For the full list of things that CBMC can check, run <code>cbmc --help</code>.</p>
<ul>
<li><a href="cbmc/overview/checking-properties.html#memory-safety">Memory safety</a></li>
<li><a href="cbmc/overview/checking-properties.html#more-pointer-checks">More pointer checks</a></li>
<li><a href="cbmc/overview/checking-properties.html#malloc-failure">Malloc failure</a></li>
<li><a href="cbmc/overview/checking-properties.html#integer-overflow">Integer overflow</a></li>
<li><a href="cbmc/overview/checking-properties.html#floating-point-overflow">Floating point overflow</a></li>
<li><a href="cbmc/overview/checking-properties.html#division-by-zero">Division by zero</a></li>
<li><a href="cbmc/overview/checking-properties.html#type-casting">Type casting</a></li>
<li><a href="cbmc/overview/checking-properties.html#bit-shifting">Bit shifting</a></li>
<li><a href="cbmc/overview/checking-properties.html#loop-unwinding">Loop unwinding</a></li>
</ul>
<h2 id="memory-safety-1"><a class="header" href="#memory-safety-1">Memory safety</a></h2>
<ul>
<li><code>--bounds-check</code> enables array bounds checking.</li>
<li><code>--pointer-check</code> enables invalid pointer checking.</li>
</ul>
<p>Given the program <a href="cbmc/overview/examples/properties/bounds.c"><code>bounds.c</code></a></p>
<pre><code class="language-c">int main() {
  int array[10];
  for (int i=0; i&lt;=10; i++) array[i] = i;
}
</code></pre>
<p>the command</p>
<pre><code class="language-bash">cbmc --bounds-check bounds.c
</code></pre>
<p>finds the off-by-one error in the loop termination condition:</p>
<pre><code>line 3 array 'array' lower bound in array[(signed long int)i]: SUCCESS
line 3 array 'array' upper bound in array[(signed long int)i]: FAILURE
</code></pre>
<p>Given the program <a href="cbmc/overview/examples/properties/pointers.c"><code>pointers.c</code></a></p>
<pre><code>int main() {
  int *ptr;
  int array[10];
  *ptr = 3;
  *(array + 10) = 4;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --pointer-check pointers.c
</code></pre>
<p>finds that <code>ptr</code> may be null and that <code>array + 10</code> points beyond the end
of <code>array</code>:</p>
<pre><code>line 4 dereference failure: pointer NULL in *ptr: FAILURE
line 4 dereference failure: pointer invalid in *ptr: FAILURE
line 4 dereference failure: deallocated dynamic object in *ptr: FAILURE
line 4 dereference failure: dead object in *ptr: FAILURE
line 4 dereference failure: pointer outside object bounds in *ptr: FAILURE
line 4 dereference failure: invalid integer address in *ptr: FAILURE
line 5 dereference failure: dead object in array[(signed long int)10]: SUCCESS
line 5 dereference failure:
  pointer outside object bounds in array[(signed long int)10]: FAILURE
</code></pre>
<p>These off-by-one errors caught with <code>--bounds-check</code> and <code>--pointer-check</code>
feel quite similar to each other, but <code>--bounds-check</code> is for index
expressions and <code>--pointer-check</code> is for pointer offsets.
We always use these flags together.</p>
<h2 id="more-pointer-checks"><a class="header" href="#more-pointer-checks">More pointer checks</a></h2>
<ul>
<li><code>--pointer-overflow-check</code> checks pointer arithmetic
for arithmetic overflow and underflow.</li>
<li><code>--pointer-primitive-check</code> checks that all pointers are either valid or null
(all pointers, not just dereferenced  pointers) when used within <a href="http://www.cprover.org/cprover-manual/api/">CBMC
builtins</a> like
<code>__CPROVER_r_okay(ptr, size)</code> that returns true if reading the piece of
memory starting at the given pointer with the given size is safe.</li>
</ul>
<p>Given the file <a href="cbmc/overview/examples/properties/pointer-overflow.c"><code>pointer-overflow.c</code></a></p>
<pre><code>#include &lt;stdint.h&gt;
int main() {
  int array[10];
  int *x = array + SIZE_MAX;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --pointer-check pointer-overflow.c
</code></pre>
<p>will succeed (because the bad pointer is never dereferenced) but
the command</p>
<pre><code>cbmc --pointer-check --pointer-overflow-check pointer-overflow.c
</code></pre>
<p>will find the overflow</p>
<pre><code>line 4 pointer arithmetic:
  dead object in array + (signed long int)18446744073709551615ul: SUCCESS
line 4 pointer arithmetic:
  pointer outside object bounds in array + (signed long int)18446744073709551615ul:
  FAILURE
</code></pre>
<p>At the moment, the flag <code>--pointer-overflow-check</code> will detect the
potential for integer overflow in the calculation of an offset into an object,
and also for an offset that would take you outside the bounds of an object,
but there is another form of overflow to be aware of.
Arithmetic overflow in pointer arithmetic
is an issue because the CBMC heap model interprets a pointer as
an object id together with an offset into the object.  Pointer arithmetic
in C uses signed integers for offsets.  So it is possible for
the desired offset into the object to have a magnitude larger than the
maximum offset CBMC is using for objects on the heap.</p>
<h2 id="malloc-failure"><a class="header" href="#malloc-failure">Malloc failure</a></h2>
<ul>
<li><code>--malloc-may-fail</code> allows any invocation of <code>malloc</code> to fail.</li>
<li><code>--malloc-fail-null</code> sets the <code>malloc</code> failure mode to returning
a null pointer.</li>
</ul>
<p>Taken together, these flags cause CBMC
to use a model of <code>malloc</code> in which it is possible for any invocation
of <code>malloc</code> to fail and return a null pointer.  Given the
program <a href="cbmc/overview/examples/properties/malloc.c"><code>malloc.c</code></a></p>
<pre><code>#include &lt;stdlib.h&gt;
main () {
  int *x = (int *) malloc(sizeof(int));
  *x = 1;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --pointer-check malloc.c
</code></pre>
<p>will succeed but the command</p>
<pre><code>cbmc --pointer-check --malloc-may-fail --malloc-fail-null malloc.c
</code></pre>
<p>will fail because it is possible for <code>malloc</code> to fail and return a
null pointer causing <code>*x</code> to dereference a null pointer:</p>
<pre><code>line 4 dereference failure: pointer NULL in *x: FAILURE
line 4 dereference failure: pointer invalid in *x: SUCCESS
line 4 dereference failure: deallocated dynamic object in *x: FAILURE
line 4 dereference failure: dead object in *x: FAILURE
line 4 dereference failure: pointer outside object bounds in *x: FAILURE
line 4 dereference failure: invalid integer address in *x: SUCCESS
</code></pre>
<h2 id="integer-overflow"><a class="header" href="#integer-overflow">Integer overflow</a></h2>
<ul>
<li><code>--signed-overflow-check</code> and <code>--unsigned-overflow-check</code>
check for integer overflow.</li>
</ul>
<p>Given the file <a href="cbmc/overview/examples/properties/integer.c">integer.c</a></p>
<pre><code>#include &lt;limits.h&gt;
int main() {
  int x;
  int y;
  if (x + y &lt;= INT_MAX)
    x = x + y;
  if (y &lt;= INT_MAX - x)
    x = x + y;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --signed-overflow-check integer.c
</code></pre>
<p>finds several possibilities for signed integer overflow
(an undefined behavior in the C standard):</p>
<pre><code>line 5 arithmetic overflow on signed + in x + y: FAILURE
line 7 arithmetic overflow on signed - in 2147483647 - x: FAILURE
line 8 arithmetic overflow on signed + in x + y: FAILURE
</code></pre>
<h2 id="floating-point-overflow"><a class="header" href="#floating-point-overflow">Floating point overflow</a></h2>
<ul>
<li><code>--float-overflow-check</code> checks for +/-Inf in floating-point arithmetic.</li>
<li><code>--nan-check</code> checks for NaN in floating-point arithmetic.</li>
</ul>
<p>Given the file <a href="cbmc/overview/examples/properties/float.c"><code>float.c</code></a></p>
<pre><code>int main() {
  float x = 100000000.0;
  for (int i = 0; i &lt; 10; i++) x = x * x;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc float.c
</code></pre>
<p>will succeed but the command</p>
<pre><code>cbmc --float-overflow-check float.c
</code></pre>
<p>will find the floating-point overflow:</p>
<pre><code>line 3 arithmetic overflow on floating-point multiplication in x * x: FAILURE
</code></pre>
<p>Given the file <a href="cbmc/overview/examples/properties/nan.c"><code>nan.c</code></a></p>
<pre><code>int main() {
  float x = 0.0 / 0.0;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc nan.c
</code></pre>
<p>will succeed but the command</p>
<pre><code>cbmc --nan-check nan.c
</code></pre>
<p>will find the NaN:</p>
<pre><code>line 2 NaN on / in 0.0 / 0.0: FAILURE
</code></pre>
<h2 id="division-by-zero"><a class="header" href="#division-by-zero">Division by zero</a></h2>
<ul>
<li><code>--div-by-zero-check</code> checks for division by zero.</li>
</ul>
<p>Given the file <a href="cbmc/overview/examples/properties/zero.c"><code>zero.c</code></a></p>
<pre><code>int main() {
  int a;
  int b;
  int result = a / b;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --div-by-zero-check zero.c
</code></pre>
<p>finds the potential for division by zero:</p>
<pre><code>line 4 division by zero in a / b: FAILURE
</code></pre>
<h2 id="type-casting"><a class="header" href="#type-casting">Type casting</a></h2>
<ul>
<li><code>--conversion-check</code> checks for values that can't be
represented after type casts.</li>
</ul>
<p>Given the file <a href="cbmc/overview/examples/properties/conversion.c"><code>conversion.c</code></a></p>
<pre><code>#include &lt;stdint.h&gt;
int main() {
  uint8_t x;
  uint16_t y;
  x = y;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc conversion.c
</code></pre>
<p>will succeed but the command</p>
<pre><code>cbmc --conversion-check conversion.c
</code></pre>
<p>finds the potential for truncation of an integer value from 16 bits to 8 bits:</p>
<pre><code>line 5 arithmetic overflow on unsigned to unsigned type conversion in (uint8_t)y:
  FAILURE
</code></pre>
<h2 id="bit-shifting"><a class="header" href="#bit-shifting">Bit shifting</a></h2>
<ul>
<li><code>--undefined-shift-check</code> enables checks for undefined shift behaviors like
shifting too far or shifting a negative value</li>
</ul>
<p>Given the program <a href="cbmc/overview/examples/properties/shift.c">'shift.c'</a></p>
<pre><code>int main() {
  int x = 1;
  int y = -1;
  int z;
  z = x &lt;&lt; 64;
  z = x &lt;&lt; -1;
  z = y &lt;&lt; 64;
  z = y &lt;&lt; -1;
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --undefined-shift-check shift.c
</code></pre>
<p>finds a number of undefined shift behaviors:</p>
<pre><code>line 5 shift distance too large in x &lt;&lt; 64: FAILURE
line 5 shift operand is negative in x &lt;&lt; 64: SUCCESS
line 6 shift distance is negative in x &lt;&lt; -1: FAILURE
line 6 shift operand is negative in x &lt;&lt; -1: SUCCESS
line 7 shift distance too large in y &lt;&lt; 64: FAILURE
line 7 shift operand is negative in y &lt;&lt; 64: FAILURE
line 8 shift distance is negative in y &lt;&lt; -1: FAILURE
line 8 shift operand is negative in y &lt;&lt; -1: FAILURE
</code></pre>
<h2 id="loop-unwinding-1"><a class="header" href="#loop-unwinding-1">Loop unwinding</a></h2>
<ul>
<li><code>--unwinding-assertions</code> enables checks that loops have been
completely unwound.</li>
</ul>
<p>Always run CBMC with the flag <code>--unwinding-assertions</code>.</p>
<p>Given the program <a href="cbmc/overview/examples/properties/loop.c"><code>loop.c</code></a></p>
<pre><code>#include &lt;stdbool.h&gt;
int main() {
  int bound;
  for (int i=0; i&lt;bound; i++)
    if (i &gt; 9) assert(false);
}
</code></pre>
<p>the command</p>
<pre><code>cbmc --unwind 10 loop.c
</code></pre>
<p>will report</p>
<pre><code>line 5 assertion 0: SUCCESS
</code></pre>
<p>This is a surprise.  The assertion is false.  Why did CBMC not discover this?
The problem is that the assertion fails only on the 10th iteration of the
loop, and we gave CBMC the flag <code>--unwind 10</code> that restricts CBMC
to 9 iterations (not 10!).
Use the flag <code>--unwinding-assertions</code> to detect mistakes like this.
The command</p>
<pre><code>cbmc --unwind 10 --unwinding-assertions loop.c
</code></pre>
<p>will report</p>
<pre><code>line 4 unwinding assertion loop 0: FAILURE
line 5 assertion 0: SUCCESS
</code></pre>
<p>Always run CBMC with the flag <code>--unwinding-assertions</code>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coverage-checking"><a class="header" href="#coverage-checking">Coverage checking</a></h1>
<p>CBMC can also do coverage checking.  You can ask CBMC to do property
checking with</p>
<pre><code class="language-bash">cbmc program.goto --check1 --check2 --check3 --unwinding-assertions
</code></pre>
<p>and do coverage checking with</p>
<pre><code class="language-bash">cbmc program.goto --check1 --check2 --check3 --cover location
</code></pre>
<p>The first command causes CBMC to do property checking,
and the second command causes CBMC to do coverage checking.
CBMC computes line coverage and computes the lines of code that CBMC was
able to exercise while doing the property checking.
Unexpectedly low code coverage is usually an indication that your proof
harness is not modeling enough program state or is otherwise
over-constraining the set of values the state can take on,
something you should probably investigate.
(Notice that the second command adds <code>--cover location</code>
and omits <code>--unwinding-assertions</code>; the two flags cannot be used together.)</p>
<p><a href="https://github.com/model-checking/cbmc-viewer">CBMC viewer</a> is a tool
that summarizes the findings of CBMC in the form of a report that can
be opened in any web browser.  One thing that viewer does is render
the coverage data in two forms.  First, it gives coverage data for the
individual functions and for the code as a whole.  Second,
in the style of <a href="https://github.com/linux-test-project/lcov">lcov</a>,
it annotates lines of source code with the colors
green and red to indicate the lines hit and missed by
CBMC.  The two representations of coverage work together to make it easier
to understand why coverage is lower than expected.
See the
<a href="https://github.com/model-checking/cbmc-viewer/releases/latest">release page</a>
and the
<a href="https://model-checking.github.io/cbmc-viewer/">documentation</a>
for more information.</p>
<p>The coverage data itself, without the aid of CBMC viewer, is a little
overwhelming for most users.  CBMC computes the set of basic blocks in the
goto program.  A basic block is a block of straight-line code ending with a
goto statement (going to the next basic block).  CBMC
annotates each basic block with a test that amounts to saying &quot;CBMC entered
this basic block at least once during property checking&quot;.  CBMC uses the
SAT solver to determine if there is any input and any path through the code
that could reach this basic block.  The output is the list of basic
blocks, and for each basic block whether CBMC entered the basic block
and the lines of source code contributing steps to the basic
block.</p>
<p>Coverage checking can take longer than property checking.  Depending on
what properties you are checking for, there can be many more basic
blocks to check than there are properties to check.  As a result, the
constraint problem for coverage checking can be both bigger and harder
to solve than for property checking.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-harnesses"><a class="header" href="#proof-harnesses">Proof harnesses</a></h1>
<p>This section is about writing proof harnesses for CBMC.
Our <a href="cbmc/overview/proof.html#memory-safety-proof-harness">proof harness overview</a>
has already introduced the notion of a proof harness,
and this section goes into greater detail about the issues to consider
when writing a harness.
The purpose of a proof harness is to build a model of the environment of
the function under test.  The purpose of this model is to collect in one
place all of the assumptions required for the proof to hold.  The proof
harness is responsible for:</p>
<ul>
<li><a href="cbmc/overview/proof-harnesses.html#modeling-input">Modeling input</a></li>
<li><a href="cbmc/overview/proof-harnesses.html#modeling-global-state">Modeling global state</a></li>
<li><a href="cbmc/overview/proof-harnesses.html#modeling-interfaces">Modeling interfaces</a></li>
<li><a href="cbmc/overview/proof-harnesses.html#allocating-data">Allocating data</a></li>
<li><a href="cbmc/overview/proof-harnesses.html#validating-data">Validating data</a></li>
<li><a href="cbmc/overview/proof-harnesses.html#proof-assumptions">Proof assumptions</a></li>
</ul>
<h2 id="modeling-input"><a class="header" href="#modeling-input">Modeling input</a></h2>
<p>For simple functions, the model of the environment is just the input to the
function.</p>
<p>Suppose we have a library <a href="cbmc/overview/examples/harness/library1.c">library1.c</a></p>
<pre><code class="language-c">#include &lt;assert.h&gt;

int alpha1(int a) {
    return a+1;
}

int beta1(int b) {
    int bb = alpha1(b);
    assert(bb == b);
}
</code></pre>
<p>and we want to test function <code>beta1</code>.  The input to function <code>beta1</code>
is an integer <code>b</code>.  We write a proof harness <a href="cbmc/overview/examples/harness/harness1.c">harness1.c</a></p>
<pre><code class="language-c">int beta1(int b);

int main() {
   int x;
   beta1(x);
}
</code></pre>
<p>that allocates an unconstrained integer named <code>x</code> and invokes <code>beta1</code> on <code>x</code>.</p>
<p>We run CBMC on the result with</p>
<pre><code class="language-bash">goto-cc -o library1.goto library1.c
goto-cc -o harness1.goto harness1.c
goto-cc -o proof1.goto library1.goto harness1.goto
cbmc proof1.goto
</code></pre>
<p>and we see a violation of the assertion <code>bb == b</code>.</p>
<pre><code class="language-bash">** Results:
library1.c function beta1
[beta1.assertion.1] line 9 assertion bb == b: FAILURE

** 1 of 1 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>Correcting this assertion to <code>bb == b + 1</code> fixes the problem.</p>
<h2 id="modeling-global-state"><a class="header" href="#modeling-global-state">Modeling global state</a></h2>
<p>Sometimes a function depends on global state.  A common example
is low-level system code that depends on a system table, and we want
to know the code works no matter what has been stored in the system
table.</p>
<p>Suppose we have a library <a href="cbmc/overview/examples/harness/library2.c">library2.c</a></p>
<pre><code class="language-c">#include &lt;assert.h&gt;

int counter = 0;

int alpha2(int a) {
    counter = counter + 1;
    return a+counter;
}

int beta2(int b) {
    int bb = alpha2(b);
    assert(bb == b + 1);
}
</code></pre>
<p>and we want to test function <code>beta2</code>.  This time the function <code>beta2</code>
depends on its input <code>b</code>, but it also depends on a global variable
<code>counter</code> that is initialized to <code>0</code> but is changed with each invocation
of <code>beta2</code>.  We want to know that <code>beta2</code> always works, no matter how
many times <code>beta2</code> has been invoked in the past.</p>
<p>We do this by writing a proof harness that chooses an unconstrained value
for both the function input <code>b</code> and the global variable <code>counter</code>.
We write a proof harness <a href="cbmc/overview/examples/harness/harness2.c">harness2.c</a></p>
<pre><code class="language-c">extern int counter;
int beta2(int b);

int main() {
    int cnt;
    counter = cnt;

    int x;
    beta2(x);
}
</code></pre>
<p>We run CBMC on the result with</p>
<pre><code class="language-bash">goto-cc -o library2.goto library2.c
goto-cc -o harness2.goto harness2.c
goto-cc -o proof2.goto library2.goto harness2.goto
cbmc proof2.goto
</code></pre>
<p>and see a violation of the assertion <code>bb == b + 1</code>.</p>
<pre><code class="language-bash">** Results:
library2.c function beta2
[beta2.assertion.1] line 12 assertion bb == b + 1: FAILURE

** 1 of 1 failed (2 iterations)
VERIFICATION FAILED
</code></pre>
<p>We correct this to <code>bb &gt;= b + 1</code> and we are done.</p>
<h2 id="modeling-interfaces"><a class="header" href="#modeling-interfaces">Modeling interfaces</a></h2>
<p>Sometimes a function depends on an implementation of an interface or
a library API that we don't care to test.
A common example is a function that depends on
a network communication protocol like HTTP with <code>send</code> and <code>receive</code>
methods.  We want our code to work independent of the protocol implementation,
so we replace the implementations of the functions in the protocol interface
with stubs that over-approximate the behaviors of the implementations.</p>
<p>Suppose we have a library <a href="cbmc/overview/examples/harness/library3.c">library3.c</a></p>
<pre><code class="language-c">#include &lt;assert.h&gt;

void send(int msg);
int receive();

int alpha(int x) {
    int y = receive();
    assert(y &gt; 0);
    return y+1;
}
</code></pre>
<p>that depends on <code>send</code> and <code>receive</code> methods from a network interface.
We stub out the network interface with <a href="cbmc/overview/examples/harness/network3.c">network3.c</a></p>
<pre><code class="language-c">int receive() {
    // model receiving an unconstrained integer value from the network
    int msg;
    return msg;
}

void send(int msg) {
    // model sending an integer over the network (nothing to do)
    return;
}
</code></pre>
<p>We write the proof harness <a href="cbmc/overview/examples/harness/harness3.c">harness3.c</a></p>
<pre><code class="language-c">int alpha(int x);

int main() {
    int x;
    alpha(x);
}
</code></pre>
<p>We run CBMC with</p>
<pre><code class="language-bash">goto-cc -o network3.goto network3.c
goto-cc -o library3.goto library3.c
goto-cc -o harness3.goto harness3.c
goto-cc -o proof3.goto network3.goto library3.goto harness3.goto
cbmc proof3.goto
</code></pre>
<p>and we get a failure of the assertion <code>y &gt; 0</code>.</p>
<p>Suppose the mistake is in our model of the network.  Suppose our
network only transmits positive integers.  Then we can fix our stub of
the <code>receive</code> method to return not an unconstrained integer but an
unconstrained positive integer.
We change our stubs for the network to <a href="cbmc/overview/examples/harness/network3a.c">network3a.c</a></p>
<pre><code class="language-c">int receive() {
    // model receiving an unconstrained POSITIVE integer value from the network
    int msg;
    __CPROVER_assume(msg &gt; 0);
    return msg;
}

void send(int msg) {
    // model sending an integer over the network (nothing to do)
    return;
}
</code></pre>
<p>We run CBMC with</p>
<pre><code class="language-bash">goto-cc -o network3a.goto network3a.c
goto-cc -o library3.goto library3.c
goto-cc -o harness3.goto harness3.c
goto-cc -o proof3.goto network3a.goto library3.goto harness3.goto
cbmc proof3.goto
</code></pre>
<p>and declare victory at the successful verification.</p>
<h2 id="allocating-data"><a class="header" href="#allocating-data">Allocating data</a></h2>
<p>For projects where functions take pointers to data on the heap, we
recommend writing functions to allocate unconstrained values on the
heap of the appropriate types for use in proof harnesses.</p>
<p>Consider a string buffer defined by</p>
<pre><code class="language-c">typedef struct { size_t length; char* buffer; } strbuf;
</code></pre>
<p>and consider a function that takes a pointer to a string buffer and
caches the fifth character in the buffer into a global variable</p>
<pre><code class="language-c">char cache;
void cache_fifth_char(strbuf* str) { cache = str-&gt;buffer[4]; }
</code></pre>
<p>Let's try to prove that this function is memory safe (although,
obviously, it is not).  Memory safety means that we never dereference
an invalid pointer and we never try to access data outside the bounds
of a valid object.  We can do this by calling CBMC with the flags
<code>--pointer-check</code> and <code>--bounds-check</code>.  Let's prove this even in the
case where malloc can fail and return NULL instead of a pointer.  The
default model of malloc in CBMC never fails, but we can change to a
model of malloc that can fail and return NULL by calling CBMC with
the flags <code>--malloc-may-fail</code> and <code>--malloc-fail-null</code>.</p>
<p>The function <code>cache_fifth_char</code> takes a pointer to a string buffer on
the heap, so let write a function that allocates a string buffer.</p>
<pre><code class="language-c">strbuf* strbuf_allocate(size_t length) {
  strbuf* str = malloc(sizeof(strbuf));
  if (str == NULL) return NULL;
  str-&gt;length = length;
  str-&gt;buffer = malloc(length);
  return str;
}
</code></pre>
<p>Now we can write a proof harness for the function</p>
<pre><code class="language-c">int main() {
  size_t len;
  strbuf* str = strbuf_allocate(len);

  cache_fifth_char(str);
}
</code></pre>
<p>Pulling all of this together into a single file
<a href="cbmc/overview/examples/harness/strbuf1.c">strbuf1.c</a>, we can run cbmc on this file
with</p>
<pre><code class="language-bash">cbmc --pointer-check --bounds-check --malloc-may-fail --malloc-fail-null strbuf1.c
</code></pre>
<p>and the result is a slew of verification failures including</p>
<pre><code class="language-bash">[cache_fifth_char.pointer_dereference.1] line 7 dereference failure: pointer NULL in str-&gt;buffer: FAILURE
[cache_fifth_char.pointer_dereference.7] line 7 dereference failure: pointer NULL in str-&gt;buffer[(signed long int)4]: FAILURE
[cache_fifth_char.pointer_dereference.11] line 7 dereference failure: pointer outside object bounds in str-&gt;buffer[(signed long int)4]: FAILURE
</code></pre>
<p>The first is saying that <code>str</code> may be NULL, the second is saying that
<code>str-&gt;buffer</code> may be NULL, and the third is saying that <code>str-&gt;buffer</code>
may not have 5 character in it.</p>
<p>We are obviously going to have to make some assumptions about the
string buffer before we can prove that the function is memory safe.</p>
<h2 id="validating-data"><a class="header" href="#validating-data">Validating data</a></h2>
<p>For projects that require allocating objects of various types on the heap, we
recommend writing predicates that say what well-formed objects of these
types look like.</p>
<p>In the case of our example, a valid pointer to a string buffer must be
nonnull, and a valid string buffer must have a buffer that is nonnull.</p>
<pre><code class="language-c">bool strbuf_is_valid(strbuf* str) {
  if (str == NULL) return false;
  if (str-&gt;buffer == NULL) return false;
  return true;
}
</code></pre>
<p>With this predicate, we can write a proof harness that assumes the string
buffer allocated on the heap is valid before calling the function.  We can
also assert that the string buffer remains valid after calling the function.
And we can assume that the buffer has at least 5 characters in it.
In fact, we can prove the this remains true after the function invocation,
meaning that the function preserves the validity of its input.</p>
<pre><code class="language-c">int main() {
  size_t len;
  strbuf* str = strbuf_allocate(len);

  __CPROVER_assume(strbuf_is_valid(str));
  __CPROVER_assume(str-&gt;length &gt; 4);

  cache_fifth_char(str);

  __CPROVER_assert(strbuf_is_valid(str), &quot;String buffer remains valid&quot;);
  __CPROVER_assert(str-&gt;length &gt; 4, &quot;String buffer remains length &gt;4&quot;);
}
</code></pre>
<p>Pulling all of this together into <a href="cbmc/overview/examples/harness/strbuf2.c">strbuf2.c</a>,
we can run CBMC</p>
<pre><code class="language-bash">cbmc --pointer-check --bounds-check --malloc-may-fail --malloc-fail-null strbuf2.c
</code></pre>
<p>and rejoice in the successful validation.</p>
<h2 id="proof-assumptions"><a class="header" href="#proof-assumptions">Proof assumptions</a></h2>
<p>Notice that in our last proof harness, we worked hard to make as
explicit as possible all of the assumptions required for memory safety
to hold: The pointer must be a valid pointer to a valid string buffer
with at least five characters in it. It is the responsibility of the
programmer to make certain that these assumptions are true when the
function is called.
All bets are off when the function is called in a weaker context where some of these assumptions are false. The memory safety proof of the function does not hold in that context since the assumptions it is based on do not hold.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-assumptions-1"><a class="header" href="#proof-assumptions-1">Proof assumptions</a></h1>
<p>A proof assumption is anything that limits the applicability of a
statement that has been otherwise proved by CBMC.
An example of a proof assumptions is the assumption that packets coming
off a network are of size at most 1024 bytes.
This proof assumption would arise if the proof harness for a function
modeled an incoming packet as any character buffer of
size at most 1024 characters.  Suppose that we run CBMC with this proof
harness, and CBMC is unable to find any memory safety errors.  We might
be tempted to say that CBMC has proved the function is memory safe.  But
the truth is that CBMC has proved the function is memory safe only when
the function is invoked on a packet of size at most 1024 characters.
We believe that such a proof has value, and that hard-to-find software
issues will be discovered in the course of writing such a proof, but
the result is not absolute proof of memory safety.</p>
<p>Just to clear, every proof in mathematics depends on proof assumptions.
In number theory, a theorem may hold for all integers <code>n</code>, assuming <code>n</code>
is nonzero.  The theorem is powerful because it is applicable to nearly
every integer.  In cryptography, a theorem may hold only if <code>n</code> is the product
of two prime numbers <code>p</code> and <code>q</code> of roughly the same size.  The theorem
may still have powerful applications, but it applies only to a much smaller
set of integers.</p>
<p>Proof assumptions must be clearly and accurately communicated to any
proof reader and to any consumer of the proof.
Doing this right may be the hardest part of proof.
It is particularly important in the context of software proof, however,
because the credibility of the proof tool and the methodology for using the
tool depends on getting this right.
Trust is hard to earn and easy to lose.</p>
<p>The two most common sources of proof assumptions are
<a href="cbmc/overview/proof-assumptions.html#memory-allocation">memory allocation</a> and
<a href="cbmc/overview/proof-assumptions.html#function-abstraction">function abstraction</a>.</p>
<h2 id="memory-allocation"><a class="header" href="#memory-allocation">Memory allocation</a></h2>
<p>There are two common proof assumptions about memory.</p>
<h3 id="size"><a class="header" href="#size">Size</a></h3>
<p>One class of assumption is size.  Some are obvious.  If the proof harness
includes</p>
<pre><code class="language-C">  size_t size;
  __CPROVER_assume(size &lt; 100);

  char *buffer = (char *) malloc(size);
</code></pre>
<p>then the buffer is assumed to be of size smaller than 100.
Some are implicit.  If the proof harness includes</p>
<pre><code class="language-C">  size_t size;

  char *buffer = (char *) malloc(size);
</code></pre>
<p>then the buffer is implicitly bounded to the size of the maximum object
that CBMC can model (which is probably smaller than the largest
size representable in a 64-bit integer, see
our discussion of the <a href="cbmc/overview/memory-model.html">memory model</a> for more information).</p>
<h3 id="invariants"><a class="header" href="#invariants">Invariants</a></h3>
<p>One class of assumption is well-formedness or implicit data structure
invariants.
Suppose the proof harness includes</p>
<pre><code class="language-C">  typedef struct {
    size_t size;
    char *buffer;
  } buffer_t;

  buffer_t *buffer = (buffer_t *) malloc(sizeof(*buffer));
  buffer-&gt;buffer = (char *) malloc(buffer-&gt;size);
</code></pre>
<p>then the proof harness is implicitly assuming that the pointer <code>buffer-&gt;buffer</code>
is either NULL or a valid pointer to a buffer of size <code>buffer-size</code>.  This
is implicitly assuming an data structure invariant about <code>buffer</code>.
Is this really something you want to assume about a buffer you receive as
input from an untrusted adversary.  Is this really something want to assume
even when <code>buffer-&gt;size == 0</code>?</p>
<h2 id="function-abstraction"><a class="header" href="#function-abstraction">Function abstraction</a></h2>
<p>There are two common kinds of function abstraction with CBMC.</p>
<h3 id="missing-functions"><a class="header" href="#missing-functions">Missing functions</a></h3>
<p>One is implicit function abstraction done automatically by CBMC.</p>
<p>When CBMC encounters
the invocation of a function <code>missing</code> and cannot find a function definition
for <code>missing</code>, CBMC issues a warning &quot;no function body for <code>missing</code>&quot; and
models the function <code>missing</code> as a function that</p>
<ul>
<li>has no side-effects (makes no change to the state), and</li>
<li>returns an arbitrary, unconstrained value of the appropriate return type.</li>
</ul>
<p>This assumption of no side-effects is a serious assumption.  Almost no
functions in C are purely functional.  On the other hand, it is
an easy way to model something like a random number generator returning
a <code>unint64_t</code> used in some cryptographic code under test.
Including the actual function definition of the random number generator
will probably be too much for CBMC, but by leaving the function
undefined (omitting the code defining the random number generator
from the build), CBMC will consider the impact on the property being
testing of every unsigned, 64-bit integer value that can possibly
be returned by the number generator.</p>
<h3 id="stubs"><a class="header" href="#stubs">Stubs</a></h3>
<p>One is explicit function abstraction written by the proof author for the proof.</p>
<p>Consider a cryptographic key generator</p>
<pre><code class="language-C">  int key_generator(void *context, public_key_t *public, private_key_t *private)
</code></pre>
<p>As with the random number generator, including the code for a cryptographic
key generator may be too much for CBMC.  Reconstructing cryptographic keys is,
after all, designed to be intractable!</p>
<p>A reasonable stub for the key generator is:</p>
<pre><code class="language-C">  int key_generator(void *context, public_key_t *public, private_key_t *private)
  {
    __CPROVER_havoc_object(public);
    __CPROVER_havoc_object(private);
    int rc;
    return rc;
  }
</code></pre>
<p>The <code>__CPROVER_havoc_object</code> function fills the objects pointed to by <code>public</code>
and <code>private</code> with arbitrary, unconstrained data.</p>
<p>This stub has the pleasing effect of considering possible every value
(well-formed or not) that could be written to <code>public</code> and <code>private</code>
by the generator,
and considering possible every integer value that could be used as a
return code.</p>
<p>This stub is, however, making the implicit assumption that the pointers
are valid.  A better stub would check that the function is being called
correctly:</p>
<pre><code class="language-C">  int key_generator(void *context, public_key_t *public, private_key_t *private)
  {
    __CPROVER_assert(context, &quot;context is nonnull&quot;);
    __CPROVER_assert(public, &quot;public is nonnull&quot;);
    __CPROVER_assert(private, &quot;private is nonnull&quot;);

    __CPROVER_havoc_object(public);
    __CPROVER_havoc_object(private);
    int rc;
    return rc;
  }
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="goto-programs"><a class="header" href="#goto-programs">Goto programs</a></h1>
<p>The goto program is the intermediate representation of a program used by
CBMC to do bounded model checking.
CBMC comes with a compiler called <code>goto-cc</code> that is intended to be a
drop-in replacement for <code>gcc</code>.  The difference is that <code>goto-cc</code> produces
a goto program instead of the executable binary produced by <code>gcc</code>.
We've already <a href="cbmc/overview/proof.html#building-code-for-proof">touched on these topics</a>
in our <a href="cbmc/overview/proof.html">overview</a> of how to use CBMC.
Most important, we've demonstrated how to use <code>goto-cc</code> to produce the
goto program and how to run CBMC on the goto program.</p>
<p>Sometimes, however, it is helpful (and just plain interesting) to look at
the goto program produced by <code>goto-cc</code>.  Two commands are particularly
helpful:</p>
<ul>
<li><code>cbmc program.goto --list-goto-functions</code> displays the function names of
all the functions appearing in the goto program <code>program.goto</code></li>
<li><code>cbmc program.goto --show-goto-functions</code> displays function bodies of all
the functions appearing in the goto program <code>program.goto</code>.</li>
</ul>
<h2 id="a-goto-program"><a class="header" href="#a-goto-program">A goto program</a></h2>
<p>Consider a little program <a href="cbmc/overview/examples/function-pointer.c">function-pointer.c</a>
that declares two functions <code>alpha</code> and <code>beta</code>,
assigns nondeterministically
one of <code>alpha</code> and <code>beta</code> to a function pointer <code>function</code>,
and then invokes the function pointed to by <code>function</code>.</p>
<pre><code class="language-c">#include &lt;assert.h&gt;

int alpha(int x) {
  return x+1;
}

int beta(int x) {
  return x+2;
}

int main() {
  int (*function)();

  int bool;
  function = bool ? alpha : beta;

  int x;
  int rc = function(x);
}
</code></pre>
<p>Let's compile the program into a goto program.</p>
<pre><code class="language-bash">goto-cc function-pointer.c -o function-pointer.goto
</code></pre>
<h2 id="the-function-names"><a class="header" href="#the-function-names">The function names</a></h2>
<p>Let's print the function names:</p>
<pre><code class="language-bash">cbmc function-pointer.goto --list-goto-functions
</code></pre>
<pre><code>__CPROVER__start /* __CPROVER__start */
__CPROVER_initialize /* __CPROVER_initialize */
alpha /* alpha */
beta /* beta */
main /* main */
</code></pre>
<p>The second <code>initialize</code> function initializes some CBMC internal variables.
The first <code>start</code> function is the entry point for the goto program.
It calls the <code>initialize</code> function followed by the <code>main</code> function.
You can print the function bodies and see this for yourself.</p>
<h2 id="the-function-bodies"><a class="header" href="#the-function-bodies">The function bodies</a></h2>
<p>Let's print the function bodies:</p>
<pre><code class="language-bash">cbmc function-pointer.goto --show-goto-functions
</code></pre>
<p>The result is a little too long to include here, but in the middle
of the function body for <code>main</code> we find</p>
<pre><code>     // 7 file function-pointers.c line 18 function main
     IF main::1::function = cast(address_of(beta), code*) THEN GOTO 1
     // 8 file function-pointers.c line 18 function main
     IF main::1::function = cast(address_of(alpha), code*) THEN GOTO 2
     // 9 file function-pointers.c line 18 function main
     ASSUME false
     // 10 file function-pointers.c line 18 function main
  1: CALL main::$tmp::return_value := beta(main::1::x)
     // 11 file function-pointers.c line 18 function main
     GOTO 3
     // 12 file function-pointers.c line 18 function main
  2: CALL main::$tmp::return_value := alpha(main::1::x)
     // 13 no location
  3: ASSIGN main::1::rc := main::$tmp::return_value
</code></pre>
<p>This is interesting because it demonstrates how CBMC handles
function pointers.  What we see is essentially a switch statement
that compares the function pointer <code>function</code> with pointers to
each of the functions whose address has been taken anywhere in the program.
In this case, pointers to the functions <code>alpha</code> and <code>beta</code>.  Depending on
the outcome of the comparison, either <code>alpha</code> or <code>beta</code> is invoked
and its return value is assigned to <code>rc</code>.</p>
<p>We include this discussion as an example of how looking at the goto program
can help debug issues with CBMC.  If, for example, CBMC were surprisingly
slow to terminate, you might look at the goto program and discover that
there is another function <code>gamma</code>
that is being considered as a possible value for <code>function</code>.
This is impossible in our example, but if <code>gamma</code> is defined in another
source file that was accidentally included in the build of the goto program,
one solution might be simply to omit that source file from the build for
this proof.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-proof-projects"><a class="header" href="#cbmc-proof-projects">CBMC proof projects</a></h1>
<p>The <a href="https://github.com/model-checking/cbmc-starter-kit">CBMC starter kit</a>
makes it easy to add CBMC verification to an existing software project.</p>
<p>In this tutorial, we show how to begin proving the memory safety of
a memory allocator that comes with the
<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel">FreeRTOS Kernel</a>.
The kernel comes with five allocators, and we look at the simplest one.
It allocates blocks from a region of memory set aside for the heap.
It maintains a linked list of free blocks and allocates a block from
the first block in the free list that is big enough to satisfy the request.
When the block is freed, it is added back to the free list and merged with
adjacent free blocks already in the free list.
The function we want to prove memory safe is the allocator
<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/portable/MemMang/heap_5.c#L155"><code>pvPortMalloc</code></a>
in the source file
<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/portable/MemMang/heap_5.c">portable/MemMang/heap_5.c</a>.</p>
<p>This tutorial is actually a slightly cleaned-up version of the work done by two
developers who used the starter kit to begin verification of <code>pvPortMalloc</code>.
These developers, who had little more hands-on experience than the demonstration of
CBMC running on a few simple examples, were able to use the starter kit
to begin verification in about ten or fifteen minutes, and were able to
breathe some real life into the proof within a few more hours.</p>
<p>Using the starter kit consists of five steps</p>
<ul>
<li><a href="starter-kit/overview/index.html#clone-the-source-repository">Clone the source repository</a></li>
<li><a href="starter-kit/overview/index.html#configure-the-repository">Configure the repository</a></li>
<li><a href="starter-kit/overview/index.html#configure-the-proof">Configure the proof</a></li>
<li><a href="starter-kit/overview/index.html#write-the-proof">Write the proof</a></li>
<li><a href="starter-kit/overview/index.html#run-the-proof">Run the proof</a></li>
</ul>
<h2 id="clone-the-source-repository"><a class="header" href="#clone-the-source-repository">Clone the source repository</a></h2>
<p>The first step is to clone the FreeRTOS Kernel repository.</p>
<pre><code>git clone https://github.com/FreeRTOS/FreeRTOS-Kernel.git kernel
cd kernel
git submodule update --init --checkout --recursive
</code></pre>
<p>The first line clones the repository into the directory <code>kernel</code>.
The remaining lines step into the directory <code>kernel</code>
and clone the kernel's submodules.</p>
<h2 id="configure-the-repository"><a class="header" href="#configure-the-repository">Configure the repository</a></h2>
<p>The next step is to configure the repository for CBMC verification.
Choose some location within the repository to create a <code>cbmc</code> directory
to hold the CBMC verification work.</p>
<pre><code>mkdir cbmc
cd cbmc
cbmc-starter-kit-setup
</code></pre>
<pre><code>What is the project name? Kernel
</code></pre>
<p>The first line creates a <code>cbmc</code> directory to hold everything
related to CBMC verification.  The last line runs a setup script
to configure the repository for CBMC verification.
It examines the layout of the repository and asks for a name to use for
the CBMC verification project.  We use the project name <code>Kernel</code>.</p>
<p>Looking at the <code>cbmc</code> directory, we see that some infrastructure has
been installed:</p>
<pre><code>ls
</code></pre>
<pre><code>include         proofs          sources         stubs
</code></pre>
<p>We see directories for holding header files, source files, and stubs written
for the verification work.  Examples of useful stubs for a verification project
are <code>send</code> and <code>receive</code> methods for a physical communication network that
isn't being explicitly modeled.</p>
<p>The most important directory here is the <code>proofs</code> directory that will hold
the CBMC proofs themselves:</p>
<pre><code>ls proofs
</code></pre>
<pre><code>Makefile-project-defines        Makefile.common
Makefile-project-targets        README.md
Makefile-project-testing        run-cbmc-proofs.py
Makefile-template-defines
</code></pre>
<p>The most important files here are</p>
<ul>
<li><code>Makefile.common</code>  This makefile
implements our best practices for CBMC verification:
our best practices for building code for CBMC, our best practices
for running CBMC, and for building a report of CBMC results in a form
that makes it easy to debug issues found by CBMC.</li>
<li><code>run-cbmc-proofs.py</code> This python script runs all of the CBMC proofs in
the <code>proofs</code> directory with maximal concurrency,
and builds a dashboard of the results.
This script is invoked by continuous integration to recheck the proofs on
changes proposed in a pull request.</li>
</ul>
<p>The remaining Makefiles are just hooks for describing project-specific
modifications or definitions.  For example, within <code>Makefile-project-defines</code>
you can define the <code>INCLUDES</code> variable to set the search path for the header
files needed to build the project functions being verified.</p>
<h2 id="configure-the-proof"><a class="header" href="#configure-the-proof">Configure the proof</a></h2>
<p>The next step is to configure the repository for the CBMC verification of
a particular function.
The function we want to verify is
<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/portable/MemMang/heap_5.c#L155"><code>pvPortMalloc</code></a>
in the source file
<a href="https://github.com/FreeRTOS/FreeRTOS-Kernel/blob/main/portable/MemMang/heap_5.c">portable/MemMang/heap_5.c</a>.</p>
<pre><code>cd proofs
cbmc-starter-kit-setup-proof
</code></pre>
<pre><code>What is the function name? pvPortMalloc
These source files define a function 'pvPortMalloc':
   0 ../../portable/ARMv8M/secure/heap/secure_heap.c
   1 ../../portable/GCC/ARM_CM23/secure/secure_heap.c
   2 ../../portable/GCC/ARM_CM33/secure/secure_heap.c
   3 ../../portable/IAR/ARM_CM23/secure/secure_heap.c
   4 ../../portable/IAR/ARM_CM33/secure/secure_heap.c
   5 ../../portable/MemMang/heap_1.c
   6 ../../portable/MemMang/heap_2.c
   7 ../../portable/MemMang/heap_3.c
   8 ../../portable/MemMang/heap_4.c
   9 ../../portable/MemMang/heap_5.c
  10 ../../portable/WizC/PIC18/port.c
  11 The source file is not listed here
Select a source file (the options are 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11): 9
</code></pre>
<p>This runs a setup script for the proof that first asks for the name
of the function being verified.  We give it the name <code>pvPortMalloc</code>.
It then examines the source code in the repository and lists all of
the source files that define a function named <code>pvPortMalloc</code>.  It lists
these files and asks us to chose the file with the implementation we
want to verify.  We choose source file number 9.</p>
<p>The <code>proofs</code> directory now contains a subdirectory <code>pvPortMalloc</code>
for verification of the memory allocator <code>pvPortMalloc</code>.</p>
<pre><code>cd pvPortMalloc
ls
</code></pre>
<pre><code>Makefile                cbmc-proof.txt          pvPortMalloc_harness.c
README.md               cbmc-viewer.json
</code></pre>
<p>The most important files in this directory are</p>
<ul>
<li><code>Makefile</code> This is a skeleton of a Makefile to build and run the proof.</li>
<li><code>pvPortMalloc_harness.c</code> This is a skeleton of a proof harness
for <code>pvPortMalloc</code>.</li>
</ul>
<h2 id="write-the-proof"><a class="header" href="#write-the-proof">Write the proof</a></h2>
<h3 id="the-makefile"><a class="header" href="#the-makefile">The Makefile</a></h3>
<p>The Makefile is very simple.</p>
<pre><code>HARNESS_ENTRY = harness
HARNESS_FILE = pvPortMalloc_harness

# This should be a unique identifier for this proof, and will appear on the
# Litani dashboard. It can be human-readable and contain spaces if you wish.
PROOF_UID = pvPortMalloc

DEFINES +=
INCLUDES +=

REMOVE_FUNCTION_BODY +=
UNWINDSET +=

PROOF_SOURCES += $(PROOFDIR)/$(HARNESS_FILE).c
PROJECT_SOURCES += $(SRCDIR)/portable/MemMang/heap_5.c

# If this proof is found to consume huge amounts of RAM, you can set the
# EXPENSIVE variable. With new enough versions of the proof tools, this will
# restrict the number of EXPENSIVE CBMC jobs running at once. See the
# documentation in Makefile.common under the &quot;Job Pools&quot; heading for details.
# EXPENSIVE = true

include ../Makefile.common
</code></pre>
<p>You can see that it identifies the the function <code>pvPortMalloc</code>, it
identifies the source file <code>portable/MemMang/heap_5.c</code>, and it includes
the <code>Makefile.common</code> describing our best practices for using CBMC.</p>
<p>It also gives us the option of defining <code>INCLUDES</code> to set the include path
for header files.  We do need a few header files to build <code>pvPortMalloc</code>,
so let us update the Makefile with</p>
<pre><code>INCLUDES += -I$(PROOFDIR)
INCLUDES += -I$(SRCDIR)/include
INCLUDES += -I$(SRCDIR)/portable/ThirdParty/GCC/Posix
</code></pre>
<p>The final <a href="starter-kit/overview/Makefile"><code>Makefile</code></a> is:</p>
<pre><code>HARNESS_ENTRY = harness
HARNESS_FILE = pvPortMalloc_harness

# This should be a unique identifier for this proof, and will appear on the
# Litani dashboard. It can be human-readable and contain spaces if you wish.
PROOF_UID = pvPortMalloc

DEFINES +=
INCLUDES += -I$(PROOFDIR)
INCLUDES += -I$(SRCDIR)/include
INCLUDES += -I$(SRCDIR)/portable/ThirdParty/GCC/Posix

REMOVE_FUNCTION_BODY +=
UNWINDSET +=

PROOF_SOURCES += $(PROOFDIR)/$(HARNESS_FILE).c
PROJECT_SOURCES += $(SRCDIR)/portable/MemMang/heap_5.c

# If this proof is found to consume huge amounts of RAM, you can set the
# EXPENSIVE variable. With new enough versions of the proof tools, this will
# restrict the number of EXPENSIVE CBMC jobs running at once. See the
# documentation in Makefile.common under the &quot;Job Pools&quot; heading for details.
# EXPENSIVE = true

include ../Makefile.common
</code></pre>
<h3 id="the-proof-harness"><a class="header" href="#the-proof-harness">The proof harness</a></h3>
<p>The proof harness is also very simple (especially after omitting some
comments at the top of the file).</p>
<pre><code>/**
 * @file pvPortMalloc_harness.c
 * @brief Implements the proof harness for pvPortMalloc function.
 */

void harness()
{

  /* Insert argument declarations */

  pvPortMalloc( /* Insert arguments */ );
}
</code></pre>
<p>We need to add the main header file <code>FreeRTOS.h</code> for the FreeRTOS project,
and we need to add a function prototype for <code>pvPortMalloc</code> saying that it
takes a size and returns a pointer.</p>
<pre><code>#include &lt;stdlib.h&gt;
#include &quot;FreeRTOS.h&quot;
void *pvPortMalloc(size_t size);
</code></pre>
<p>All that is left is to declare an unconstrained size of type <code>size_t</code> and
pass it to <code>pvPortMalloc.</code></p>
<pre><code>size_t size;
pvPortMalloc(size);
</code></pre>
<p>The final <a href="starter-kit/overview/pvPortMalloc_harness.c"><code>pvPortMalloc_harness.c</code></a> is:</p>
<pre><code>/**
 * @file pvPortMalloc_harness.c
 * @brief Implements the proof harness for pvPortMalloc function.
 */

#include &lt;stdlib.h&gt;
#include &quot;FreeRTOS.h&quot;
void *pvPortMalloc(size_t size);

void harness()
{
  size_t size;
  pvPortMalloc(size);
}
</code></pre>
<p>And that is it, with the exception of one last detail.  Building FreeRTOS
requires a configuration file that sets all the parameters used to define
a system configuration.  This kernel repository does not contain a
configuration file, so let us use a simplified
configuration file from a demonstration in another repository.  Let us add
<a href="starter-kit/overview/FreeRTOSConfig.h"><code>FreeRTOSConfig.h</code></a> to the <code>pvPortMalloc</code> directory.</p>
<h2 id="run-the-proof"><a class="header" href="#run-the-proof">Run the proof</a></h2>
<p>Finally, we can run the proof.  In the directory containing the proof, we run</p>
<pre><code>make
</code></pre>
<p>This builds a report of the results that we can open in a browser</p>
<pre><code>open report/html/index.html
</code></pre>
<p>Examining <a href="starter-kit/overview/report/index.html">the report</a>, we see a list of coverage results, a list of
warnings, and a list of errors or issues found by CBMC.  In this report,
there are no errors, but the coverage is <em>terrible</em>: only 40% of the lines
in the function are exercised by CBMC!</p>
<p>Further thought makes it clear that we haven't set up the heap
that the allocator is supposed to be using.  We have invoked
an allocator to allocate space on a heap, but we haven't allocated
or initialized the heap itself yet!</p>
<p>At this point it is interesting to see what the developers
did to breathe some life into this verification effort.
Their proof harness looked something like this
<a href="starter-kit/overview/pvPortMalloc_harness1.c"><code>pvPortMalloc_harness.c</code></a>:</p>
<pre><code>/**
 * @file pvPortMalloc_harness.c
 * @brief Implements the proof harness for pvPortMalloc function.
 */

#include &lt;stdlib.h&gt;
#include &quot;FreeRTOS.h&quot;
void * pvPortMalloc( size_t xWantedSize );

void harness()
{
  /* allocate heap */
  uint8_t app_heap[ configTOTAL_HEAP_SIZE ];

  /* initialize heap */
  HeapRegion_t xHeapRegions[] =
    {
      { ( unsigned char * ) app_heap, sizeof( app_heap ) },
      { NULL,                         0                  }
    };
  vPortDefineHeapRegions( xHeapRegions );

  /* mess up heap */
  size_t xWantedSize1, xWantedSize2, xWantedSize3;
  void* pv1 = pvPortMalloc( xWantedSize1 );
  void* pv2 = pvPortMalloc( xWantedSize2 );
  void* pv3 = pvPortMalloc( xWantedSize3 );
  vPortFree( pv2 );

  size_t xWantedSize;
  pvPortMalloc( xWantedSize );
}
</code></pre>
<p>You can see that they allocate the heap, they initialize the heap
data structures, and then they mess up the heap a bit by allocating
three chunks of unconstrained size and freeing the middle one.
Then they invoke <code>pvPortMalloc</code> with an unconstrained size.
Doing this was enough to get complete code coverage and uncover a
few minor instances of integer overflow.</p>
<p>Of course, this is not a complete proof of memory safety.  This is a proof that
if you allocate a heap consisting of a single chunk of memory of a size
fixed by the configuration, and if you allocate three chunks of unconstrained
size and free the middle one, then <code>pvPortMalloc</code> will exhibit no memory
safety errors or other undefined behaviors.  But it is an elegant example
of how quickly developers were able to get started doing real work.
Good for them!  And, soon, good for you.</p>
<h2 id="run-all-the-proofs"><a class="header" href="#run-all-the-proofs">Run all the proofs</a></h2>
<p>To run a single proof, as we have already seen, just change to the directory
containing the proof and run</p>
<pre><code>make
open report/html/index.html
</code></pre>
<p>to run the proof and open a summary of the results in a web browser.</p>
<p>To run all proofs in the repository, there a script installed
by the starter kit that will run all proofs in the repository
and summarize the results in a report that you can open in a web
browser.
Just change to the directory <code>cbmc/proofs</code> and run the script with</p>
<pre><code>run-cbmc-proofs.py
</code></pre>
<p>When the script is done it will print a line like</p>
<pre><code>Report was rendered at file:////repository/cbmc/proofs/output/latest/html/index.html
</code></pre>
<p>You can open this report in a web browser</p>
<pre><code>open file:////repository/cbmc/proofs/output/latest/html/index.html
</code></pre>
<p>and see a summary of the results.  The results will list the proofs that
failed at the top.  For each proof, you can click within the column labeled
&quot;Report&quot; to see the same html report you would see if you ran the proof
on its own.  You can also click on the &quot;pipeline&quot; icon on the left
to see the logs for each stage in the pipeline that built the code and
ran the proof.</p>
<p>This run script is the script to run from continuous integration.
Continuous integration can run this script and use the report it
generates to report the results back to the users.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="frequently-asked-questions"><a class="header" href="#frequently-asked-questions">Frequently asked questions</a></h1>
<p>Here are answers to some frequently-asked questions about CBMC.
Please send us any questions you have by
<a href="https://github.com/model-checking/cbmc-training/issues">filing an issue with us</a>
on GitHub.</p>
<ul>
<li><a href="faq/cbmc.html">How does CBMC work?</a></li>
<li><a href="faq/loop-unwinding.html">What is loop unwinding?</a></li>
<li><a href="faq/memory-model.html">How do memory pointers work?</a></li>
<li><a href="faq/">How do function pointers work?</a></li>
<li><a href="faq/malloc.html">How does malloc work?</a></li>
<li><a href="faq/proof-assumptions.html">What is a proof assumption?</a></li>
<li><a href="faq/">How do I write a good stub?</a></li>
<li><a href="faq/termination.html">What do I do when CBMC won't stop?</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-cbmc-work"><a class="header" href="#how-does-cbmc-work">How does CBMC work?</a></h1>
<p>The most complete descriptions of how CBMC works are</p>
<ul>
<li><a href="http://www.kroening.com/papers/dac2003.pdf">Behavioral Consistency of C and Verilog Programs Using Bounded Model
Checking</a></li>
<li><a href="http://reports-archive.adm.cs.cmu.edu/anon/2003/CMU-CS-03-126.pdf">Behavioral Consistency of C and Verilog Programs</a></li>
<li><a href="http://cprover.diffblue.com">CProver developer documentation</a></li>
</ul>
<p>The first two documents are the original paper on CBMC and a follow-up
technical report giving a bit more detail.  They are excellent introductions,
but they are a bit old.  The third document is a collection of documents for
developers.  They provide guidance on how to understand the source code.</p>
<p>CBMC uses a technique called
<a href="https://en.wikipedia.org/wiki/Symbolic_execution">symbolic execution</a>
to turn a program into a set of symbolic constraints that describe
the behavior of the program (the paths through the program).</p>
<p>For example, consider the following code fragment</p>
<pre><code>  int x;
  x = x+1;
</code></pre>
<p>CBMC sees the first statement and knows that <code>x</code> should be represented by
a vector of 32 binary variables describing the 32-bit binary value of <code>x</code>.
CBMC sees the second statement and generates a constraint that says,
&quot;If <code>X0</code> and <code>X1</code> are binary vectors describing the value of <code>x</code>
before and after the assignment, then <code>X1</code> is <code>X0</code> plus 1.&quot;  CBMC uses
a Boolean description of a binary adder that adds the 32 bits of <code>X0</code> and
the 32 bits of <code>1</code>, and generates a constraint that the i-th bit of <code>X1</code> is
equal to the Boolean expression for the i-th bit of the adder's output
on inputs <code>X0</code> and <code>1</code>.</p>
<p>Proceeding in this way, statement by statement, CBMC constructs a collection
of constraints that describe the program behavior.  The constraints
describe as a collection of Boolean formulas how the
state of the program changes during an execution.</p>
<p>CBMC then formulates the following question for each property we
want to check about the program: &quot;Does there exist an input and a path
through the program that violates the property?&quot;  CBMC formulates
this question as a constraint problem, and hands the constraint problem
to a constraint solver called a SAT solver.  The SAT solver looks for
an assignment of values to variables that satisfies the constraint
describing what a property violation would look like.</p>
<p>If the SAT solver can produce a satisfying assignment, then CBMC can take the
satisfying assignment and --- essentially reversing the process of generating
the constraints in the first place --- use the assignment to generate an
error trace describing the input (the initial state) and each step through
the program leading to a violation of the property.</p>
<p>If the SAT solver cannot produce a satisfying assignment, this amounts
to a proof that there is no input and no path through the program that
can violate the property.  Taking all these properties together,
if these properties describe memory safety, then this amounts to a proof
that the program is memory safe.</p>
<p>A proof of memory safety, of course, assuming all the assumptions the
proof harness is
making.  See our discussion of <a href="faq/proof-assumptions.html">proof assumptions</a> for more information.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-is-loop-unwinding"><a class="header" href="#what-is-loop-unwinding">What is loop unwinding?</a></h1>
<p>CBMC is a bounded model checker.  CBMC works by
executing a program for some bounded number of steps and looking
for issues that occur within those steps.  CBMC does not execute a
program concretely in the same way that a computer would execute the program
(would execute the result of compiling the program).
Instead,
CBMC <a href="https://en.wikipedia.org/wiki/Symbolic_execution">symbolically executes</a>
the program to turn it into a set of symbolic constraints that can be solved by
a constraint solver like a SAT solver.</p>
<p>But where does this bound come from?  And how do we know the bound
is the right one?</p>
<h2 id="loop-bounds"><a class="header" href="#loop-bounds">Loop bounds</a></h2>
<p>If the program contains no loops and contains no recursion, then every
execution of the program is finite, and CBMC can figure out the length
of the longest execution and use this as the bound.  Sometime CBMC
can figure this out even when the program contains loops.  For example,
CBMC can loop at the loop</p>
<pre><code>  for (int i=0; i &lt; 10; i++)
    buffer[i] = ' ';
</code></pre>
<p>and figure out on its own that the loop iterates at most 10 times.
But CBMC needs some help with the loop</p>
<pre><code>  while (TRUE)
    if (i &lt; buffer.size) buffer.data[i] = ' ' else break;
</code></pre>
<p>We need to give CBMC a bound on the number of times this loop iterates.
We need to tell CBMC how many times to unwind this loop during its
symbolic execution of the program.</p>
<p>We can do this in two ways.</p>
<ul>
<li>
<p><strong>Bound all loops</strong>: We can instruct CBMC to unwind every loop at
most <code>K</code> times with <code>cbmc --unwind K</code>. If you are using the CBMC
starter kit, this bound 1 by default, but you can change this
to <code>K</code> in your Makefile with</p>
<pre><code>  UNWIND=K
</code></pre>
</li>
<li>
<p><strong>Bound one loop</strong>: We can instruct CBMC to unwind a specific loop
at most <code>K</code> times with <code>cbmc --unwindset FUNC.NUM:K</code> where <code>FUNC</code>
is the name of the function containing the loop and <code>NUM</code> is the
number of the loop within the function (more on loop numbers below).
If you are using the CBMC starter kit, we recommend that you set
this bound in your Makefile with</p>
<pre><code>   UNWINDSET+=FUNC.NUM:K
</code></pre>
</li>
</ul>
<h2 id="loop-unwinding-assertions-1"><a class="header" href="#loop-unwinding-assertions-1">Loop unwinding assertions</a></h2>
<p>Now we know how to tell CBMC to unwind a loop <code>K</code> times, but how do we
know that unwinding a loop <code>K</code> times is enough?  What if the problem
we are looking for occurs on iteration <code>K+1</code> and we have asked CBMC to
unwind the loop only <code>K</code> times?  We could miss the issue and never know
it because we didn't tell CBMC to work hard enough to find it!</p>
<p>CBMC has solution called &quot;loop unwinding assertions.&quot;
A loop unwinding assertion is a check that a loop has been completely unwound.
It checks that the loop termination condition is guaranteed to be true
after the specified number of unwindings.
First CBMC unwinds the loop, and then CBMC inserts a assertion that
the loop termination condition is true immediately after the final
unwinding of the loop.
If there is any execution of the program in which you haven't unwound
the loop enough times, CBMC will identify the loop by its
loop name <code>FUNC.NUM</code> in the list of checks that have failed.</p>
<p>Invoking CBMC with <code>cbmc --unwinding-assertions</code> will ask CBMC to check
unwinding assertions.</p>
<center>Always invoke CBMC with <code>cbmc --unwinding-assertions</code>.</center>
<p>You can rest assured that CBMC is always invoked
with <code>cbmc --unwinding-assertions</code> if you are using the CBMC starter kit.</p>
<h2 id="counting-loop-iterations"><a class="header" href="#counting-loop-iterations">Counting loop iterations</a></h2>
<p>There are two ways to count loop iterations:</p>
<ul>
<li>One is the number of times <code>B</code> that the loop body is traversed.</li>
<li>One is the number of times <code>T</code> that the loop termination is checked.</li>
</ul>
<p>These two numbers differ by one: <code>T = B + 1</code>.</p>
<p>When you invoke CBMC, the number <code>K</code> that you give to <code>--unwind</code> or
<code>--unwindset</code> is interpreted as the number of times the loop termination
is checked: <code>K = T = B+1</code>.</p>
<p>This off-by-one business sometimes confuses people, and sometimes makes
it challenging to write a Makefile where arithmetic like <code>B+1</code> is difficult.
One style we have developed is to write a proof harness</p>
<pre><code class="language-C">int main() {
  size_t length;
  __CPROVER_assume(length &lt; LENGTH);

  char *buffer = (char *) malloc(length);
  for (int i=0; i &lt; length; i++) buffer[i] = ' ';
  ...
}
</code></pre>
<p>and to write a Makefile</p>
<pre><code class="language-Makefile">LENGTH=100
DEFINES += -DLENGTH=$(LENGTH)
UNWINDSET += main.0:$(LENGTH)
</code></pre>
<p>Because <code>length</code> is assumed to be strictly less than <code>LENGTH</code>, we know
that <code>length + 1</code> is at most <code>LENGTH</code>, so unwinding the loop <code>main.0</code>
at most <code>LENGTH</code> times is unwinding the loop at least <code>length + 1</code> times
as desired.</p>
<p>A final comment on this off-by-one issue:
At some point in the future, you may come to learn that
you can also pass the <code>cbmc</code> flags <code>--unwind</code> and <code>--unwindset</code> to a tool
named <code>goto-instrument</code>.  For historical reasons, <code>cbmc</code> interprets <code>K</code> as
<code>K=T</code> and <code>goto-instrument</code> interprets <code>K</code> as <code>K=B</code>.
Of course, when choosing between unrolling a loop <code>T=B+1</code> and <code>B</code> times,
it is always safe to unroll a loop more times than necessary.
But it may not be practical: If the loop body is
large and you are already unrolling a loop many times, the difference between
unrolling <code>K</code> and <code>K+1</code> times many push CBMC execution time from &quot;okay&quot;
to &quot;way too long.&quot;
Just something to keep in mind when using these tools.</p>
<h2 id="debugging-loop-unwinding"><a class="header" href="#debugging-loop-unwinding">Debugging loop unwinding</a></h2>
<p>When not using the starter kit, which uses <code>--unwind 1</code> by default, you may find
yourself in a situation where CBMC keeps unwinding a loop, even when you
expected CBMC to be able to determine the loop bound. CBMC uses constant
propagation and algebraic simplification to evaluate the loop guard.  CBMC will
stop unwinding the loop when, using this process, the loop guard evaluates to
false. If you would like to debug a case of unexpected loop unwinding, proceed
as described below. We will use the following example to illustrate these steps:</p>
<pre><code class="language-C">int main()
{
  int step;
  for(int i = 0; i &lt; 5; i += step) ;
}
</code></pre>
<p>Note that <code>step</code> is unconstrained, perhaps unintentionally so.
Running CBMC on this example without any additional options yields:</p>
<pre><code>&gt; cbmc loop.c
[...]
Starting Bounded Model Checking
Unwinding loop main.0 iteration 1 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 2 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 3 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 4 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 5 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 6 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 7 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 8 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 9 file loop.c line 4 function main thread 0
Unwinding loop main.0 iteration 10 file loop.c line 4 function main thread 0
[...]
</code></pre>
<p>until you manually abort this process. One way to understand why this is
happening is to undertake the following steps:</p>
<ol>
<li>Run CBMC with whatever options you normally do, but add some finite unrolling
bound using <code>--unwind</code> and also add <code>--program-only</code>. This will yield as
output the equation system generate by symbolic execution. Pipe the output to
some text file. We exemplify this on the above example:
<pre><code>&gt; cbmc loop.c --program-only --unwind 2
[...]
Starting Bounded Model Checking
Unwinding loop main.0 iteration 1 file loop.c line 4 function main thread 0
Not unwinding loop main.0 iteration 2 file loop.c line 4 function main thread 0
[...]
Program constraints:
[...]
// 2 file loop.c line 4 function main
(26) i!0@1#2 == 0
// 3 file loop.c line 4 function main
// 4 file loop.c line 4 function main
(27) i!0@1#3 == step!0@1#1
// 5 file loop.c line 4 function main
// 3 file loop.c line 4 function main
// 3 file loop.c line 4 function main
(28) \guard#1 == !(i!0@1#3 &gt;= 5)
// 4 file loop.c line 4 function main
(29) i!0@1#4 == i!0@1#3 + step!0@1#1
     guard: \guard#1
[...]
</code></pre>
The above output is an excerpt from the equation system generated by symbolic
execution. We see assignments to the loop counter <code>i</code> turned into equations
over its renamed (in static single assignment (SSA) form) instantiations. The
loop guard is found as <code>\guard#1</code>.</li>
<li>Search for the source location where you expect the constant to appear in the
loop guard. In our example, this is &quot;file loop.c line 4.&quot;</li>
<li>Once you have found the assignment or equality defining the loop guard that
doesn't have the expected constant on the right-hand side (in the example,
this could be the equality over <code>\guard#1</code>), work backwards
from that right-hand side to see where you last had a constant. That is,
backwards-search for the name appearing on the right-hand side, which will
eventually appear as a left-hand side. Now repeat this process for the new
right-hand side of this equation, until the right-hand side is a constant. In
the example, the only time we find a constant as right-hand side is the
initial assignment, <code>i!0@1#2 == 0</code>.</li>
<li>The expression where you flip from is-a-constant to is-a-symbol is the
culprit. For our example, this is <code>i!0@1#3 == step!0@1#1</code>. You will then
conclude that either this behavior is as expected, meaning your source
program does not permit constant propagation (our example does not permit
constant propagation, because <code>step</code> is unconstrained; setting it to some
constant value will result in bounded loop unwinding), or a shortcoming in
CBMC's simplification process. In the latter case, report an issue or
contribute a patch to address this.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-do-memory-pointers-work"><a class="header" href="#how-do-memory-pointers-work">How do memory pointers work?</a></h1>
<p>A pointer in C points to a memory location.  It is a string of 32 or
64 bits interpreted as an unsigned integer denoting a memory
address.  CBMC, however, interprets this same string of bits as object id
followed by an offset into the object denoted by the object id.</p>
<p>CBMC models the heap as a collection of objects.  Each object has an
id and a size.  A pointer consists of an object id and an offset into
the object.  CBMC encodes the id and offset into a C pointer by using the
top bits for the object id and the bottom bits for the offset into the object.
By default, CBMC uses the top 8 bits for the object id and the bottom
56 bits for the offset in 64-bit code (and the bottom 24 bits in 32-bit code).</p>
<p><strong>Object id</strong>:
The number of bits used to represent the object id is 8 by default.
It can be changed to <code>K</code> with the flag <code>--object-bits K</code> that is passed
to the compiler <code>goto-cc</code> and to <code>cbmc</code> itself.
It is important that the same value <code>K</code> be passed to <code>goto-cc</code> and <code>cbmc</code>.
If you are using the CBMC starter kit, you set <code>K</code> in your Makefile with</p>
<pre><code>CBMC_OBJECT_BITS = K
</code></pre>
<p>You may see CBMC fail with an error message saying that CBMC tried to
allocate &quot;too many objects.&quot;
One option is to increase the number of
object bits and see if the problem goes way.  Even if this works, it is
worth getting your hands dirty and trying to understand why CBMC
needs to allocate so many objects for your code.
Remember that CBMC is exploring all
paths through your code, and has to model all of the objects allocated
in all of these paths.
In the best case, you will discover a way to reduce the number of objects
produced by your code, and produce better code.
In the worst case, you may find it prudent to bound the size of a data
structure (maybe the size of an input buffer) to bound the number of
objects CBMC has to model.</p>
<p><strong>Object offset</strong>:
The number of bits used to represent the offset into the object is
the number of remaining bits in a pointer.  This is 56 by default in
64-bit code and 24 by default in 32-bit code.</p>
<ul>
<li>
<p>The maximum offset is the maximum size of an object that can be
modeled in CBMC.  This maximum size is smaller than the maximum size
that can (at least theoretically) be used in a C program.  This is a
proof assumption, and it needs to be made clear to the readers or
customers of a proof who need to know exactly what CBMC has proved
about the code.  If you are using the CBMC starter kit, you can access
this maximum size using the preprocessor definition
<code>CBMC_MAX_OBJECT_SIZE</code> as in the code fragment</p>
<pre><code>size_t size;
char *ptr;

__CPROVER_assume(size &lt;= CBMC_MAX_OBJECT_SIZE);
ptr = (char *) malloc(size);
</code></pre>
</li>
<li>
<p>The offset is a <em>signed</em> integer.  In pointer arithmetic, the
difference <code>ptr1 - ptr2</code> can be negative or positive depending on
whether <code>ptr1</code> points before or after <code>ptr2</code>.  This means that the
maximum size of an object with a 56- or 24-bit offset is actually
the maximum positive number that can be represented in 55 or 23
bits.  If you are using the CBMC starter kit, this maximum positive
number is <code>CBMC_MAX_OBJECT_SIZE</code>.</p>
</li>
</ul>
<p>CBMC provides a few <a href="https://github.com/diffblue/cbmc/blob/develop/src/ansi-c/cprover_builtin_headers.h">intrinsics</a> that can be useful in a proof harness:</p>
<ul>
<li><code>__CPROVER_POINTER_OBJECT(ptr)</code> is the id of the object denoted by ptr.</li>
<li><code>__CPROVER_POINTER_OFFSET(ptr)</code> is the offset into the object denoted by ptr.</li>
<li><code>__CPROVER_OBJECT_SIZE(ptr)</code> is the size of the object denoted by ptr.</li>
<li><code>__CPROVER_same_object(ptr1, ptr2)</code> is true if ptr1 and ptr2 point to
the same object.</li>
<li><code>__CPROVER_is_invalid_pointer(ptr)</code> is true if ptr is a valid pointer.</li>
</ul>
<p>CBMC provides a few <a href="https://github.com/diffblue/cbmc/blob/develop/src/ansi-c/cprover_builtin_headers.h">functions</a> that can be useful in a proof harness.  These
functions havoc an object, which means they set all or some of the object
to an arbitrary, unconstrained value.  The word &quot;havoc&quot; means
&quot;widespread destruction&quot;.  To &quot;wreak havoc&quot; means &quot;to cause great damage&quot;.
We havoc an object to search for an object value that will induce an
issue in our code like a memory safety error or integer overflow.</p>
<ul>
<li><code>__CPROVER_havoc_object(ptr)</code> havocs the entire object denoted by the
object id in <code>ptr</code>.</li>
<li><code>__CPROVER_havoc_slice(ptr, length)</code> havocs the portion of the object
starting at the offset denoted by the object offset in <code>ptr</code>
and extending   for <code>length</code> bytes.</li>
</ul>
<p>For more information, see the CBMC tutorial on
<a href="http://cprover.diffblue.com/memory-primitives.html">memory primitives</a> and CBMC
<a href="http://www.cprover.org/cprover-manual/api/">builtin functions</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="how-does-malloc-work"><a class="header" href="#how-does-malloc-work">How does malloc work?</a></h1>
<p>CBMC has several models of <code>malloc</code>.</p>
<p>In one model of <code>malloc</code> (the default model), the function never fails
to allocate an object on the heap and always returns a valid pointer to a
valid object.  In particular, <code>malloc</code> will never return <code>NULL</code>,
<code>malloc</code> will never run out of memory, and <code>malloc</code> will never fail.</p>
<p>This is a problem if you are using CBMC to check for memory safety issues,
because <code>malloc</code> can fail and return <code>NULL</code>, and trying to dereference a
null pointer is one of the issues you want to check for.</p>
<p>In other models of <code>malloc</code>, the function can nondeterministically
choose to fail and return <code>NULL</code>, and the function will fail if it is
asked to allocate an object that is larger than CBMC can model (see
the notion of object bits in the discussion of the
<a href="faq/memory-model.html">CBMC memory model</a>).  These models of <code>malloc</code> are used
when CBMC is invoked with the
flags <code>--malloc-may-fail</code> and <code>--malloc-fail-null</code>.</p>
<p>We recommend that you use <code>--malloc-may-fail</code> and <code>--malloc-fail-null</code>.
Do not use the default model of <code>malloc</code>.
The CBMC starter kit uses both flags by default.</p>
<p>One last comment about <code>malloc</code>: The invocation <code>malloc(0)</code> can return
a valid pointer to nothing.
The C standard says that invoking <code>malloc</code> with size 0
should return a pointer that can be passed to <code>free</code> but cannot be
dereferenced.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="what-do-i-do-when-cbmc-wont-stop"><a class="header" href="#what-do-i-do-when-cbmc-wont-stop">What do I do when CBMC won't stop?</a></h1>
<p>CBMC goes through several stages.  CBMC can theoretically get stuck in any
stage, but the most commonly slow stages are</p>
<ul>
<li>Doing the symbolic execution</li>
<li>Generating the SAT formula from the symbolic execution</li>
<li>Solving the SAT formula with the SAT solver</li>
</ul>
<p>Almost always the problem is just one or two lines of code.  For example,
under certain circumstances something as simple as</p>
<pre><code>  memcpy(dst, src, length);
</code></pre>
<p>can cause CBMC to become stuck generating the SAT formula that results from
considering all places <code>dst</code> and <code>src</code> might be pointing.</p>
<p>The first problem is to find the line of code.  Most programmers are
used to delta debugging in which the programmer performs a kind of
binary search on the code to find the problem.  Delete more and more
from the bottom of the function under test until CBMC no longer hangs.
The problem is in the last block of code (the last line) deleted that
caused CBMC to terminate.</p>
<p>The second problem is to fix the problem.  Usually the solution involves
some form of function abstraction.  It is a known problem, for example,
for the standard library functions <code>memcpy</code>, <code>memmove</code>, and <code>memset</code>
to be a problem.  It is a common solution to abstract these functions
to havoc the entire destination object and not just the portion being
updated.  This works because functions under test commonly copy data to
the output and never look at the data actually copied.  A simple stub
for <code>memcpy</code> would be</p>
<pre><code class="language-C">void memcpy(char *dst, char *src, size_t length) {
  __CPROVER_havoc(dst);
}
</code></pre>
<p>A better stub would check that <code>src</code> and <code>dst</code> are nonnull pointers to
nonoverlapping regions of memory.  For a good stub, see <a href="https://github.com/awslabs/aws-c-common/blob/main/verification/cbmc/stubs/memcpy_override_havoc.c">memcpy</a> in the <a href="https://github.com/awslabs/aws-c-common">AWS C Common</a> repository.</p>
<p>A final tip is that sometimes it is interesting to know which stage
of CBMC is taking so long.  The
output of CBMC can general indicate where the problem is.  Running CBMC with</p>
<pre><code>  cbmc --flush
</code></pre>
<p>will flush to the terminal log messages saying that a given stage
is starting or finishing.  This usually gives some hint.  The most
difficult stage to debug is why CBMC is taking so long to generate
the SAT formula.  If the problem is the SAT solver is taking too long,
you may be able to figure out what is going on by running CBMC with
one flag at a time (eg, check <code>--bounds-check</code> and then check
<code>--unsigned-overflow-check</code>) until you can identify the check that is
taking so much time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-projects"><a class="header" href="#cbmc-projects">CBMC projects</a></h1>
<p>This is a short tutorial on how to use CBMC on a software project.  We discuss:</p>
<ul>
<li><a href="management/Plan-your-proof.html">Project planning</a>:
How organize your proof, estimate the effort involved, and estimate
the return on investment</li>
<li><a href="management/Write-a-good-proof.html">Writing a good proof</a>:
What does a good proof look like?</li>
<li><a href="management/Debug-an-error-trace.html">Debugging an error trace</a>:
How to debug and repair an issue discovered by CBMC</li>
<li><a href="management/Code-for-verification.html">Coding for verification</a>:
How to write code to make it easy to prove with CBMC</li>
<li><a href="management/Code-review-for-proofs.html">Proof evaluation</a>:
A checklist for proof writers and reviewers to know when a proof is
done</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-planning"><a class="header" href="#project-planning">Project planning</a></h1>
<h2 id="how-to-select-what-proofs-to-attempt-in-what-order"><a class="header" href="#how-to-select-what-proofs-to-attempt-in-what-order">How to select what proofs to attempt, in what order</a></h2>
<ol>
<li>Make a dependency graph of the modules in your program.
There are a number of tools that can help with this, including <a href="https://www.doxygen.nl/manual/">doxygen</a>.
In addition, you can manually determine a good approximation to the dependency graph using the <code>.h</code> files.
If a module includes the <code>.h</code> file of another module, it likely depends on it.</li>
<li>Select the leaves of the graph - those modules which other modules depend upon, but which do not depend on other modules themselves.
Typically, these include the basic data-structures and algorithms used by the rest of the codebase.
Which one of these you choose is a matter of style: you can use the  <a href="management/Code-for-verification.html">guidelines for coding for verification</a> to help select modules which are likely to be good verification targets.</li>
<li>Inside a given module, select the best initial verification target.
This is often, but not always, one of the simpler functions.
In particular, you are looking for a function which is both easy to verify, and will give good insight into the data-structure invariants of the data-structures used in the given module.
The more a function conforms to our <a href="management/Code-for-verification.html">guidelines for coding for verification</a>, the easiest it will be to verify.
In our experience, it often makes sense to start with allocation or initialization functions (which often have named that end in <code>_alloc()</code> or <code>_init()</code>.</li>
<li>The first proof for a given module is typically the hardest.
It typically requires the creation of an <code>_is_valid()</code> function and an <code>_ensure_is_allocated()</code> function.
However, once these have been written once, the remainder of the module becomes much easier.
The amount of time needed to complete a proof can vary significantly, from hours for a simple proof to days for a complex one.
If the function has few dependencies, and conforms to the guidelines for coding for verification, we would expect an initial proof to take perhaps a day's work.[TODO I made up this number.  We need data]
If it is taking longer than this, try a different entry-point.</li>
</ol>
<h2 id="how-to-get-a-sense-of-the-work-cbmc-will-involve"><a class="header" href="#how-to-get-a-sense-of-the-work-cbmc-will-involve">How to get a sense of the work CBMC will involve</a></h2>
<p>We recommend selecting a few (2-3) modules from the leaves of the dependency graph, and then doing 2-3 proofs from each module.
This will give you a sense of</p>
<ol>
<li>How much work the first proof in a new module is</li>
<li>How much work subsequent proofs in that module is, once the <code>_is_valid()</code> and <code>_ensure_is_allocated()</code> functions are written.</li>
</ol>
<p>Predicting precisely how hard a piece of code will be to verify can be difficult.
In general, however, the more code conforms to our <a href="management/Code-for-verification.html">guidelines for coding for verification</a>, the easier it will be to verify.
We recommend trying  modules of different verification complexity to get a sense of overall expected effort.</p>
<p>Particular features to look for are:</p>
<ol>
<li>Does the code have loops?
<ol>
<li>If so, are those loops nested?
Since CBMC unrolls loops before verifying them, nested loops can lead to a quadratic (or worse) increase in the amount of work CBMC will need to perform.</li>
<li>Are they over fixed sizes, or do they vary with the size of inputs?
If loops are of fixed size, it may be hard to simplify the problem if CBMC is having performance issues as the proof is being developed.
On the other hand, once the proof is complete, functions with fixed-sized loops may have higher assurance proofs, since data-structures do not need to be bounded for performance reasons.</li>
</ol>
</li>
<li>Does the code use inductive data-structures (e.g. linked lists, trees)?
Inductive data-structures are much harder to model and verify than linear structures such as arrays.</li>
<li>Does the code have function pointers?
Function pointers are hard to model.
They can also cause performance problems for CBMC.</li>
<li>Does the code have an simple and obvious specification?
One of the main challenges in verification is writing the specification.
The simpler the specification of the code being verified, the easier it is to verify.
Similarly, the better the documentation, the easier it is.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="writing-a-good-proof"><a class="header" href="#writing-a-good-proof">Writing a good proof</a></h1>
<p><strong>Table of Contents</strong></p>
<ul>
<li><a href="management/Write-a-good-proof.html#the-components-of-a-cbmc-proof">The components of a CBMC proof</a></li>
<li><a href="management/Write-a-good-proof.html#running-example">Running example.</a></li>
<li><a href="management/Write-a-good-proof.html#the-proof-harness">The Proof harness</a>
<ul>
<li><a href="management/Write-a-good-proof.html#what-does-a-good-proof-harness-look-like">What does a good proof harness look like?</a></li>
<li><a href="management/Write-a-good-proof.html#how-to-write-a-good-proof-harness">How to write a good proof harness</a></li>
</ul>
</li>
<li><a href="management/Write-a-good-proof.html#the-proof-makefile">The Proof Makefile</a></li>
<li><a href="management/Write-a-good-proof.html#the-is_valid-function">The <code>is_valid()</code> function</a>
<ul>
<li><a href="management/Write-a-good-proof.html#example-of-an-is_valid-function">Example of an <code>is_valid()</code> function</a></li>
</ul>
</li>
<li><a href="management/Write-a-good-proof.html#the-ensure_allocated-function">The <code>ensure_allocated</code> function</a></li>
<li><a href="management/Write-a-good-proof.html#stubs-and-abstractions">Stubs and abstractions</a></li>
<li><a href="management/Write-a-good-proof.html#how-do-i-add-the-function-contract-to-the-function-being-verified">How do I add the function contract to the function being verified?</a>
<ul>
<li><a href="management/Write-a-good-proof.html#example-using-function-contracts">Example using function contracts</a></li>
</ul>
</li>
</ul>
<h2 id="the-components-of-a-cbmc-proof"><a class="header" href="#the-components-of-a-cbmc-proof">The components of a CBMC proof</a></h2>
<p>A CBMC proof normally consists of several components:</p>
<ol>
<li>
<p>A <strong>proof harness</strong> which:</p>
<ol>
<li>Sets up required data-structures</li>
<li>Calls the function being verified</li>
<li>Checks any function post-conditions</li>
</ol>
</li>
<li>
<p>A <strong>proof makefile</strong> which:</p>
<ol>
<li>Defines any necessary preprocessor defines
e.g. <code>-DMAX_BUFFER_SIZE=10</code></li>
<li>Specifies the dependencies of the code under test</li>
<li>Specifies any abstractions or models used by proof</li>
</ol>
<p>Much of the work done by these Makefiles is common among proofs.
We provide a <code>Makefile.common</code>, which provides useful makefile rules shared by all proofs.</p>
</li>
<li>
<p>A set of <strong><code>_is_valid()</code> functions</strong>, one for each <strong>datatype</strong> used in the proof</p>
<ol>
<li>Typically go in the code-base itself</li>
<li>Can be used in the codebase as assertions to improve runtime checking.</li>
<li>Can be reused by multiple proofs</li>
</ol>
</li>
<li>
<p>A set of <strong><code>_allocate()</code> and <code>ensure()</code> functions</strong>,  one for each <strong>datatype</strong> used in the proof</p>
<ol>
<li>Due to limitations of the CBMC tools, not all properties about a datatype can be described declaratively.
In particular, allocation of memory must be done imperatively.
These functions handle allocation of the data-structure, and any recursive substructures.</li>
<li>Can be put in a library and reused by multiple proofs.</li>
</ol>
</li>
<li>
<p>A <strong>library of helper functions</strong> which:</p>
<ol>
<li>Models any external libraries (e.g. libCrypto)</li>
<li>Provides implementations for abstracted functions</li>
</ol>
</li>
</ol>
<p>The remainder of this document describes how build one of these components.</p>
<h2 id="running-example"><a class="header" href="#running-example">Running example</a></h2>
<p>We will use the <code>aws_array_list</code> module from the <a href="https://github.com/awslabs/aws-c-common">AWS C Common</a> open-source project as our running example.
This module provides a polymorphic array defined as follows:</p>
<pre><code class="language-c">struct aws_array_list {
    struct aws_allocator *alloc;
    size_t current_size;
    size_t length;
    size_t item_size;
    void *data;
};
</code></pre>
<ul>
<li><code>alloc</code> represents the allocator used by the list (to allow consumers of the list to override <code>malloc</code> if desired)</li>
<li><code>current_size</code> represents the bytes of memory that the array has allocated</li>
<li><code>length</code> is the number of items that it contains</li>
<li><code>item_size</code> represents the size of the objects stored in the list (in bytes)</li>
<li><code>data</code> points to a byte array in memory that contains the data of the array list.</li>
</ul>
<p>Users of this data structure are expected to access its fields using getter and setter methods, although C does not offer language support to ensure that they do so.
Similarly, since the C type system does not have support for polymorphism, authors of the getters and setters are responsible for ensuring that the list is accessed safely.
The getter itself is defined as:</p>
<pre><code class="language-c">int aws_array_list_get_at_ptr(const struct aws_array_list *AWS_RESTRICT list, void **val, size_t index) {
    if (aws_array_list_length(list) &gt; index) {
        *val = (void *)((uint8_t *)list-&gt;data + (list-&gt;item_size * index));
        return AWS_OP_SUCCESS;
    }
    return aws_raise_error(AWS_ERROR_INVALID_INDEX);
}
</code></pre>
<h2 id="the-proof-harness-1"><a class="header" href="#the-proof-harness-1">The Proof harness</a></h2>
<h3 id="what-does-a-good-proof-harness-look-like"><a class="header" href="#what-does-a-good-proof-harness-look-like">What does a good proof harness look like?</a></h3>
<p>Syntactically, a proof harness looks quite similar to a unit test.
The main difference is that a proof harness calls the target function with a partially-constrained input rather than a concrete value; when symbolically executed by CBMC, this has the effect of exploring the function under <em>all</em> possible inputs that satisfy the constraints.</p>
<p>We have developed a style of writing proofs that we believe is readable, maintainable, and modular.
This style was driven by feedback from developers, and addresses the need to communicate <em>exactly what we are proving</em> to developers and users.</p>
<p>Our proofs have the following features:</p>
<ol>
<li>They are structured as <em>harnesses</em> that call into the function being verified, similar to unit tests.
This makes them easier to write, because they follow a pattern most developers are familiar with.
This style also yields more useful error traces.
Most importantly, it makes proofs easier to understand and maintain, since a developer reviewing a proof has an &quot;executable&quot; which they can understand using their existing knowledge and intuition about C code.</li>
<li>They state their assumptions declaratively.
Rather than creating a fully-initialized data structure in imperative style, we create unconstrained data structures and then constrain them just enough to prove the property of interest.
This means the only assumptions on the data structure's values are the ones we state in the harness.</li>
<li>They follow a predictable pattern: setting up data structures, assuming preconditions on them, calling into the code being verified, and asserting postconditions.</li>
</ol>
<p>The following code is an example of a proof harness:</p>
<pre><code class="language-c">void aws_array_list_get_at_ptr_harness() {
    /* initialization */
    struct aws_array_list* list = can_fail_malloc(sizeof(*list));
    __CPROVER_assume(list != NULL));
    __CPROVER_assume(aws_array_list_is_bounded(list));
    ensure_array_list_has_allocated_data_member(list);

    /* generate unconstrained inputs */
    void **val = can_fail_malloc(sizeof(void *));
    size_t index;

    /* preconditions */
    __CPROVER_assume(aws_array_list_is_valid(list));
    __CPROVER_assume(val != NULL);

    /* call function under verification */
    if(!aws_array_list_get_at_ptr(list, val, index)) {
        /* If aws_array_list_get_at_ptr is successful,
         * i.e. ret==0, we ensure the list isn't
         * empty and index is within bounds */
        assert(list-&gt;data != NULL);
        assert(list-&gt;length &gt; index);
    }

    /* postconditions */
    assert(aws_array_list_is_valid(list));
    assert(val != NULL);
}
</code></pre>
<p>The harness shown above consists of five parts:</p>
<ol>
<li>Initialize the data structure to unconstrained values.
We recommend initializers for all verified data structures use a consistent naming scheme:
<code>ensure_{data_structure}_has_allocated_data_member()</code>.</li>
<li>Generate unconstrained inputs to the function.</li>
<li>Constrain all inputs to meet the function specification and assume all preconditions using <code>assume</code> statements.
If necessary, bound the data structures so that the proof terminates.</li>
<li>Call the function under verification with these inputs.</li>
<li>Check any function postconditions using <code>assert</code> statements.</li>
</ol>
<h3 id="how-to-write-a-good-proof-harness"><a class="header" href="#how-to-write-a-good-proof-harness">How to write a good proof harness</a></h3>
<p>We recommend approaching writing a proof-harness as an iterative process:</p>
<ol>
<li>
<p>Write a minimally constrained harness, which simply</p>
<ol>
<li>declares the necessary variables</li>
<li>and then calls the function under test using them.</li>
</ol>
<p>For example, for the harness given above, an initial harness might look like:</p>
</li>
</ol>
<pre><code class="language-c">void aws_array_list_get_at_ptr_harness() {
    /* initialization */
    struct aws_array_list* list;

    /* generate unconstrained inputs */
    void **val;
    size_t index;

    /* call function under verification */
    aws_array_list_get_at_ptr(list, val, index);
}
</code></pre>
<p>Note that we are leaving the inputs to the function completely unconstrained: we are simply declaring them on the stack, and then using them without assigning any values to them.
In a normal C compiler, this would be undefined behavior.
In CBMC, this is legal, but represents an <strong>unconstrained value</strong> (you may also hear this called a <strong>non-deterministic</strong> value).
The CBMC tool will use a mathematical solver which considers every possible value of an unconstrained variable.
If there exists a value which can cause an assertion failure, the solver will find it.
Conversely, if the solver says the assertion cannot be violated, this forms mathematical <em>proof</em> that no such value exists.</p>
<p>Leaving these values unconstrained will almost certainly lead to CBMC detecting violations, because real functions have implicit (or, if you're lucky, explicit) constraints on their inputs.
For example, it is typically a precondition of a function that pointers must either reference valid memory, or be <code>null</code>.
However, sometimes you may be surprised: if a function doesn't use a given input, or uses it in a defensive way, it may accept totally unconstrained values.
What we are attempting to do is find the minimum constraint that will allow the function to succeed with no assertion violations.
So we start with unconstrained values, and slowly constrain them just enough to get the function to verify.</p>
<ol>
<li>Run CBMC and observe the output.
In the case of our running example, you will see errors that look like this</li>
</ol>
<pre><code>   Errors
     * In include/aws/common/array_list.inl
       * In aws_array_list_get_at_ptr
         * Line 347:
           * [trace] val != ((void*)0) check failed
</code></pre>
<p>We have already seen examples of <a href="management/../cbmc/overview/debugging.html">CBMC error traces</a> like this,
and we will soon give more guidance on <a href="management/Debug-an-error-trace.html">debugging CBMC error traces</a>.</p>
<ol>
<li>
<p>Constrain each input in turn until all warnings are resolved.
See the sections on writing <code>_is_valid()</code> and <code>_ensure_is_allocated()</code> functions for details on how to do this</p>
</li>
<li>
<p>Fix any loop-unwinding errors.
To fix these errors, you will need to update the Makefile with the correct loop bounds.
This may cause CBMC to get quite slow.
In this case, we recommend <strong>bounding</strong> the size of data-structures to allow CBMC to finish quickly.
In the harness above, this is accomplished by the line</p>
<pre><code>__CPROVER_assume(aws_array_list_is_bounded(list))
</code></pre>
<p>We recommend starting with very small bounds to ensure a quick debug cycle.
Once the proof is finished, you can increase the bounds to give proofs for longer lists.</p>
</li>
<li>
<p>Check the coverage report.
Ideally, you will have 100% coverage.
In practice, coverage will be less than 100%, for e.g. in defensive code that redundantly checks for errors.
In this case, inspect the uncovered code, and ensure that it matches your expectations.</p>
</li>
<li>
<p>Strengthen the proof by adding assertions to the harness that check more properties.
There are typically three types of such assertions:</p>
<ol>
<li>Data structures should remain valid, whether or not the function under test succeeded.</li>
<li>If the function failed, data-structures should remain unchanged.</li>
<li>If the function succeeded, data-structures should be updated according to the function semantics.</li>
</ol>
<p>In our example harness, this is handled by the lines</p>
</li>
</ol>
<pre><code class="language-c">    /* call function under verification */
    if(!aws_array_list_get_at_ptr(list, val, index)) {
        /* If aws_array_list_get_at_ptr is successful,
         * i.e. ret==0, we ensure the list isn't
         * empty and index is within bounds */
        assert(list-&gt;data != NULL);
        assert(list-&gt;length &gt; index);
    }

    /* postconditions */
    assert(aws_array_list_is_valid(list));
    assert(val != NULL);
</code></pre>
<h2 id="the-proof-makefile"><a class="header" href="#the-proof-makefile">The Proof Makefile</a></h2>
<p>The Makefile for our running example looks like this:</p>
<pre><code class="language-make"># Sufficiently long to get full coverage on the aws_array_list APIs
# short enough that all proofs complete quickly
MAX_ITEM_SIZE ?= 2
DEFINES += -DMAX_ITEM_SIZE=$(MAX_ITEM_SIZE)

# Necessary to get full coverage when using functions from math.h
MAX_INITIAL_ITEM_ALLOCATION ?= 9223372036854775808ULL
DEFINES += -DMAX_INITIAL_ITEM_ALLOCATION=$(MAX_INITIAL_ITEM_ALLOCATION)

# This bound allows us to reach 100% coverage rate
UNWINDSET += memcpy_impl.0:$(shell echo $$(($(MAX_ITEM_SIZE) + 1)))

CBMCFLAGS +=

DEPENDENCIES += $(HELPERDIR)/source/proof_allocators.c
DEPENDENCIES += $(HELPERDIR)/source/make_common_data_structures.c
DEPENDENCIES += $(HELPERDIR)/source/utils.c
DEPENDENCIES += $(HELPERDIR)/stubs/error.c
DEPENDENCIES += $(HELPERDIR)/stubs/memcpy_override.c
DEPENDENCIES += $(SRCDIR)/source/array_list.c
DEPENDENCIES += $(SRCDIR)/source/common.c

ENTRY = aws_array_list_get_at_ptr_harness
###########

include ../Makefile.common
</code></pre>
<ol>
<li>It defines a set of variables that can be used as bounds in the proof.
As discussed above, we recommend starting with small bounds to enable quick iteration on the proof and increasing them once the proof is complete.
These variables are created both as Makefile variables, which can be used later (e.g. in the <code>UNWINDSET</code>, and also passed as <code>-D</code> defines, which allow</li>
<li>It creates an <code>UNWINDSET</code> which tells CBMC how many times to unroll loops in the program.
As shown here, loop bounds typically depend on variables within the Makefile.
Its a good idea to make this explicit, as we do here, to avoid the need to change magic constants as you experiment with the proof.</li>
<li>A list of <code>CBMCFLAGS</code> if any are needed.
Typically, all the required flags are set in the <code>Makefile.common</code>, and this can be left empty</li>
<li>A list of <code>DEPENDENCIES</code>, which are the
<ol>
<li>Project source files</li>
<li>Proof stubs/models [TODO, this really belongs in ABSTRACTIONS]</li>
</ol>
</li>
<li>The <code>ENTRY</code>, which is the name of the function being verified</li>
<li><code>include ../Makefile.common</code> to take advantage of the standard templates declared in that file.</li>
</ol>
<p>Most makefiles should like exactly like this.
[TODO discuss wellspring, litani]</p>
<h2 id="the-is_valid-function"><a class="header" href="#the-is_valid-function">The <code>is_valid()</code> function</a></h2>
<p>The <code>is_valid()</code> functions used in preconditions are developed using an iterative process.
For each <strong>data-structure</strong> module, start by specifying the simplest predicates that you can think of for the data structure --- usually, that the data of the data structure is correctly allocated.
Then, gradually refine these predicates, until you have a set of reasonable invariants for the data structure.</p>
<p>You can verify that invariants are reasonable by:</p>
<ol>
<li>
<p>Having an explicit code-review in which subject matter experts on the development team confirm that the invariants represent the design intent of the code</p>
</li>
<li>
<p>Adding these invariants as pre/post-conditions to the code being verified, and ensuring that all unit and regression tests pass.
Note that unit-test failures do not necessarily reflect problems with your invariants.
They may also reflect either</p>
<ol>
<li>Bugs in the code itself</li>
<li>Bugs in the unit-tests</li>
</ol>
<p>In both these cases, fix the bug in the code, then make sure the invariant now succeeds during the tests.</p>
</li>
</ol>
<h3 id="example-of-an-is_valid-function"><a class="header" href="#example-of-an-is_valid-function">Example of an <code>is_valid()</code> function</a></h3>
<p>For instance, in the case of the <code>array_list</code>, we started
with the invariant that <code>data</code> points to <code>current_size</code>
allocated bytes.
After several iterations, the validity invariant for <code>array_list</code> ended up looking like this:</p>
<pre><code class="language-c">bool aws_array_list_is_valid(const struct aws_array_list *list) {
  if (!list) return false;
  size_t required_size = 0;
  bool required_size_is_valid = (aws_mul_size_checked(list-&gt;length, list-&gt;item_size, &amp;required_size) == AWS_OP_SUCCESS);
  bool current_size_is_valid = (list-&gt;current_size &gt;= required_size);
  bool data_is_valid = ((list-&gt;current_size == 0 &amp;&amp; list-&gt;data == NULL) || AWS_MEM_IS_WRITABLE(list-&gt;data, list-&gt;current_size));
  bool item_size_is_valid = (list-&gt;item_size != 0);

  return required_size_is_valid &amp;&amp; current_size_is_valid &amp;&amp; data_is_valid &amp;&amp; item_size_is_valid;
}
</code></pre>
<p>The invariant above describes four conditions satisfied by a valid <code>array_list</code>:</p>
<ol>
<li>the sum of the sizes of the items of the list must fit in an unsigned integer of type <code>size_t</code>, which is checked using the function <code>aws_mul_size_checked</code></li>
<li>the size of the <code>array_list</code> in bytes (<code>current_size</code>) has to be larger than or equal to the sum of the sizes of its items;</li>
<li>the <code>data</code> pointer must point to a valid memory location; otherwise it must be <code>NULL</code> if the size of the <code>array_list</code> is zero;
This point is actually somewhat subtle: there was debate among the team about whether the pointer must be <code>NULL</code>, or whether any value was legal if the length was zero.
Writing an explicit <code>is_valid()</code> function forced the team to come to a precise decision.</li>
<li>the <code>item_size</code> must be positive.</li>
</ol>
<h2 id="the-ensure_allocated-function"><a class="header" href="#the-ensure_allocated-function">The <code>ensure_allocated</code> function</a></h2>
<p>Ideally, all properties in a proof harness would be written in a declarative style.
Unfortunately, CBMC currently does not allow to use <code>__CPROVER_assume()</code> statements to assume that memory is correctly allocated for some data structure as a precondition for function verification.
Instead, memory must be explicitly allocated in the harness before calling the function under analysis using imperative calls to <code>malloc()</code>.
By default, CBMC <code>malloc()</code> never returns <code>null</code>.
So it is important that your <code>ensure_allocated</code> function explicitly defines cases where pointers can be <code>null</code>, using adequately placed calls to <code>__CPROVER_assume({some pointer} == null)</code>.</p>
<p>It is important to separate the work done in this function from the work done in an <code>is_valid</code> function.
This function should only worry about allocating the memory needed by the data-structure.
Any other validity constraints should be handled by the <code>is_valid()</code> check.</p>
<p>The <code>ensure</code> function for the running example is:</p>
<pre><code class="language-c">void ensure_array_list_has_allocated_data_member(struct aws_array_list *const list) {
    if (list-&gt;current_size == 0 &amp;&amp; list-&gt;length == 0) {
        __CPROVER_assume(list-&gt;data == NULL);
        list-&gt;alloc = can_fail_allocator();
    } else {
        list-&gt;data = bounded_malloc(list-&gt;current_size);
        list-&gt;alloc = nondet_bool() ? NULL : can_fail_allocator();
    }
}
</code></pre>
<h2 id="stubs-and-abstractions"><a class="header" href="#stubs-and-abstractions">Stubs and abstractions</a></h2>
<ul>
<li>TODO</li>
</ul>
<h2 id="how-do-i-add-the-function-contract-to-the-function-being-verified"><a class="header" href="#how-do-i-add-the-function-contract-to-the-function-being-verified">How do I add the function contract to the function being verified?</a></h2>
<p>We strongly recommend adding all checks and assumptions from the proof harness to the function being verified as runtime assertions.
This provides value in several ways.</p>
<ol>
<li><strong>It connects the code and the proof.</strong>
Proofs for all but the most simple functions require environment assumptions.
One of the most common ways proof can go wrong is when these assumptions are actually false when the function is called in the real world.
Adding the assumptions as runtime assertions in the code allows such mismatches to be detected as the code runs.
Some teams choose to enable these assertions only in debug mode; this allows mismatches to be detected during the standard unit and integration testing processes without any performance penalty on production code.
Other teams enable these assertions for all builds, providing increased assurance at a small runtime cost.</li>
<li><strong>It helps detect bugs in the broader codebase.</strong>
On a number of occasions, adding function contracts to correct code detected violations of function contracts in other parts of the code base.
In several cases, we discovered errors in other projects, which were calling verified APIs with invalid parameters.
Even though those projects had never been formally verified, they still benefited from the function contracts developed during the formal verification work.</li>
<li><strong>It helps focus the mind.</strong>
It is easy to let standards slip during code-reviews for test and verification code.
&quot;Even if its not perfect, its better than nothing, so might as well just click approve.&quot;
Adding the proof assumptions and checks to the codebase itself as runtime assertions causes reviewers to take them much more seriously, which leads to both increased proof quality, and improved code quality.</li>
</ol>
<h3 id="example-using-function-contracts"><a class="header" href="#example-using-function-contracts">Example using function contracts</a></h3>
<p>In the running example, our verification harness assumed the following preconditions</p>
<pre><code class="language-c">    __CPROVER_assume(aws_array_list_is_valid(list));
    __CPROVER_assume(val != NULL);
</code></pre>
<p>These directly translate into preconditions in the function under test:</p>
<pre><code class="language-c">    AWS_PRECONDITION(aws_array_list_is_valid(list));
    AWS_PRECONDITION(val != NULL);
</code></pre>
<p>Similarly, the key postcondition checked in the verification harness is</p>
<pre><code class="language-c">    assert(aws_array_list_is_valid(list))
</code></pre>
<p>This also directly translates into a postcondition in the function under test:</p>
<pre><code class="language-c">    AWS_POSTCONDITION(aws_array_list_is_valid(list));
</code></pre>
<p>Putting it all together:</p>
<pre><code class="language-c">int aws_array_list_get_at_ptr(
    const struct aws_array_list* list,
    void **val,
    size_t index)
{
    AWS_PRECONDITION(aws_array_list_is_valid(list));
    AWS_PRECONDITION(val != NULL);
    if (aws_array_list_length(list) &gt; index) {
        *val = (void *)((uint8_t *)list-&gt;data +
                        (list-&gt;item_size * index));
        AWS_POSTCONDITION(aws_array_list_is_valid(list));
        return AWS_OP_SUCCESS;
    }
    AWS_POSTCONDITION(aws_array_list_is_valid(list));
    return aws_raise_error(AWS_ERROR_INVALID_INDEX);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="debugging-an-error-trace"><a class="header" href="#debugging-an-error-trace">Debugging an error trace</a></h1>
<ul>
<li><a href="management/Debug-an-error-trace.html#i-see-12-proof-failures-how-do-i-select-which-one-to-debug">I see 12 proof failures. How do I select which one to debug?</a></li>
<li><a href="management/Debug-an-error-trace.html#how-do-i-debug-a-proof-failure">How do I debug a proof failure?</a>
<ul>
<li><a href="management/Debug-an-error-trace.html#read-the-trace">Read the trace</a></li>
<li><a href="management/Debug-an-error-trace.html#add-additional-information-to-the-trace">Add additional information to the trace</a></li>
<li><a href="management/Debug-an-error-trace.html#delta-debugging">Delta debugging</a></li>
<li><a href="management/Debug-an-error-trace.html#add-assertions-to-check-your-hypotheses">Add assertions to check your hypotheses.</a></li>
<li><a href="management/Debug-an-error-trace.html#use-assert0-to-dump-program-state-leading-to-a-checkpoint">Use <code>assert(0)</code> to dump program state leading to a checkpoint</a></li>
<li><a href="management/Debug-an-error-trace.html#use-assume-to-block-uninteresting-paths">Use <code>assume(...)</code> to block uninteresting paths</a></li>
<li><a href="management/Debug-an-error-trace.html#consider-the-possibility-it-is-a-fault-in-the-code-itself">Consider the possibility it is a fault in the code itself</a></li>
</ul>
</li>
<li><a href="management/Debug-an-error-trace.html#how-do-i-improve-proofs-with-low-coverage">How do I improve proofs with low coverage?</a>
<ul>
<li><a href="management/Debug-an-error-trace.html#fix-any-cbmc-errors">Fix any CBMC errors</a></li>
<li><a href="management/Debug-an-error-trace.html#check-for-truly-unreachable-code">Check for truly unreachable code.</a></li>
<li><a href="management/Debug-an-error-trace.html#check-for-over-constrained-inputs">Check for over-constrained inputs</a></li>
</ul>
</li>
<li><a href="management/Debug-an-error-trace.html#how-can-i-tell-if-my-proof-is-over-constrained">How can I tell if my proof is over-constrained?</a></li>
<li><a href="management/Debug-an-error-trace.html#what-should-i-do-if-cbmc-crashes">What should I do if CBMC crashes?</a></li>
</ul>
<!-- END doctoc generated TOC please keep comment here to allow auto update -->
<h2 id="i-see-12-proof-failures-how-do-i-select-which-one-to-debug"><a class="header" href="#i-see-12-proof-failures-how-do-i-select-which-one-to-debug">I see 12 proof failures. How do I select which one to debug?</a></h2>
<p>CBMC proof failures seem to come in batches: you run the proof, and see a dozen different errors reported
In many cases, these failures are related: instead of stressing about the number of failures, pick one, debug it, and see if fixing it removes (many of) the others.
Some good heuristics for deciding which failure to investigate:</p>
<ol>
<li><strong>Look for a failure that occurs early on in the proof.</strong>
This will often be the one with the shortest trace [TODO viewer should output this information].
The shorter the trace leading to the issue, the easier it is to debug.</li>
<li><strong>Look for a failure in code you understand.</strong>
Some functions are simpler than others: a failure in a simple function is often easier to analyze that one in a complicated function.
And a failure in a function you understand is easier than one in a function you are not familiar with.</li>
<li><strong>Look for a simple type of failure.</strong>
For example, the trace from a null dereference is often easier to follow than the traces from other uses of bad pointers.
But they're normally exactly the same bug!
Since null dereference bugs normally give the simplest traces, start with them first.
Often, resolving the null dereference also fixes the other related bugs.</li>
</ol>
<h2 id="how-do-i-debug-a-proof-failure"><a class="header" href="#how-do-i-debug-a-proof-failure">How do I debug a proof failure?</a></h2>
<p>There are a number of techniques that have proven useful in debugging proof failures.</p>
<h3 id="read-the-trace"><a class="header" href="#read-the-trace">Read the trace</a></h3>
<p>[TODO link to a guide to viewer]
CBMC viewer generates a step-by-step trace that leads to the assertion violation.
This trace details</p>
<ul>
<li>Every line of code executed</li>
<li>Every function call made</li>
<li>Every time a variable is assigned</li>
</ul>
<p>Essentially, this trace contains everything you would get from attaching a debugger to the program, and single stepping until the violation occurred.
Take a look at the values of the relevant variables right before the assertion violation.
Do they make sense?
If not, figure out where they were assigned.
I often find that <code>Ctrl-F</code> is my friend here: I search for either the variable name, or the value it was assigned, and see where it appears in the trace.</p>
<p>Similarly, look at the set of function calls that led to the error.
Do they make sense?
Are there functions you expect to see there, but don't?
Are there functions you didn't expect to see there, but do?</p>
<h3 id="add-additional-information-to-the-trace"><a class="header" href="#add-additional-information-to-the-trace">Add additional information to the trace</a></h3>
<p>The trace has all the information you need to understand the state of program memory at every point during the execution.
But its not always that easy to reconstruct.
In particular, the trace records the value of a variable when it is written to.
But it doesn't record the value of a variable that is only read, or passed along to another function.</p>
<p>You can solve this by adding &quot;dummy writes&quot; to the program.
For example, let's say you were debugging an error that involved the following function</p>
<pre><code>int foo(struct bar* b, int x) {
    baz(b-&gt;data, x);
}
</code></pre>
<p>Figuring out the value of <code>b-&gt;data</code> and <code>x</code> are possible given a complete trace, but its difficult.
Any it might harder to figure out the value of <code>b-&gt;size</code>.
Instead, annotate the code to track those values:</p>
<pre><code>int foo(struct bar* b, int x) {
        struct bar debug_foo_b = *b;
        int debug_foo_x = x;
    baz(b-&gt;data, x);
}
</code></pre>
<p>the trace will now contain an assignment to <code>debug_foo_b</code>, which will let you see what values each member of the struct had.</p>
<h3 id="delta-debugging"><a class="header" href="#delta-debugging">Delta debugging</a></h3>
<p><a href="http://web2.cs.columbia.edu/%7Ejunfeng/09fa-e6998/papers/delta-debug.pdf">Delta debugging</a> is a powerful technique for localizing faults and creating minimal reproducing test-cases.
Essentially, you modify the program in some way, typically either by removing (commenting out) or modifying code.
You then rerun the verification tool, and see if the results changed.
The goal is to either:</p>
<ol>
<li>produce a small program which still displays the bug or</li>
<li>produce a small change between two programs, one of which has the bug, and the other doesn't.</li>
</ol>
<p>In case 1, you now have a small program which is hopefully easy to understand;
In case 2, you have a small change which induces the bug, and hopefully leads you toward the root cause.</p>
<h3 id="add-assertions-to-check-your-hypotheses"><a class="header" href="#add-assertions-to-check-your-hypotheses">Add assertions to check your hypotheses.</a></h3>
<p>For example, consider the case of a null pointer dereference of a pointer <code>p</code>.
It is important to distinguish the case where the pointer <em>must</em> be null, vs the case where it <em>may</em> be null, vs the case where it <em>is never</em> null.
You can test for these cases by adding <code>assert(p)</code> to the function.
If the can be null, the assertion will trigger.
If it cannot be null, the assertion will succeed.</p>
<p>Now, check <code>assert(!p)</code> instead.
If can be non-null, this assertion will fail.
If it can only be null, this assertion will succeed.</p>
<p>You now know which one of the three cases is true.
And you can use the trace to see why it can be null/non-null.</p>
<p>You can do similar things to determine why a branch is reachable, or unreachable.</p>
<h3 id="use-assert0-to-dump-program-state-leading-to-a-checkpoint"><a class="header" href="#use-assert0-to-dump-program-state-leading-to-a-checkpoint">Use <code>assert(0)</code> to dump program state leading to a checkpoint</a></h3>
<p>Sometimes, you want to know how/whether a particular line of code is reachable.
One easy way to learn that is to put <code>assert(0)</code> right before the line.
CBMC will detect the assertion violation, and give a trace explaining how it reached there, and with what values.
If the assertion passes without error, you know that the line is unreachable given the current proof harness.</p>
<h3 id="use-assume-to-block-uninteresting-paths"><a class="header" href="#use-assume-to-block-uninteresting-paths">Use <code>assume(...)</code> to block uninteresting paths</a></h3>
<p>There are often many possible execution paths that reach a given line of code / assertion.
Some of these may reflect cases you are trying to understand, while others do not help with your current debugging plan.
Left to its own devices, CBMC will non-deterministically choose one of those traces, which may not be the one you want.
You can guide CBMC to the trace you want by sprinkling <code>__CPROVER_assume()</code> statements within the code.
For example, you might <code>__CPROVER_assume()</code> that a function fails with an error code, to test whether the calling function handles that error code correctly.
Or you might <code>__CPROVER_assume()</code> that a given variable is null, to simplify you search for the root cause of a null dereference.</p>
<h3 id="consider-the-possibility-it-is-a-fault-in-the-code-being-verified"><a class="header" href="#consider-the-possibility-it-is-a-fault-in-the-code-being-verified">Consider the possibility it is a fault in the code being verified</a></h3>
<p>In many cases, the error detected by CBMC represents a true issue within the code being verified.
This is particularly common in the case of functions which fail to validate their inputs.
In this case, the fix is either to validate the inputs, and return an error if given invalid inputs, or to document the requirements on the inputs, and state that actions on illegal inputs are undefined behavior.
Which solution you choose depends on the risk profile of the code.</p>
<p>It is also common that code being verified has integer-overflows and other errors that only occur in unusual circumstances.
In these cases, the solution is to either guarantee that inputs are sufficiently small to prevent these issues, or to use overflow-safe built-ins, such as gcc's <code>__builtin_mul_overflow</code> (documented <a href="https://gcc.gnu.org/onlinedocs/gcc/Integer-Overflow-Builtins.html">here</a>).</p>
<h2 id="how-do-i-improve-proofs-with-low-coverage"><a class="header" href="#how-do-i-improve-proofs-with-low-coverage">How do I improve proofs with low coverage?</a></h2>
<h3 id="fix-any-error-detected-by-cbmc"><a class="header" href="#fix-any-error-detected-by-cbmc">Fix any error detected by CBMC</a></h3>
<p>Make sure that there are no missing function definitions, or property violations.
Both of these errors can affect coverage calculations.</p>
<h3 id="check-for-truly-unreachable-code"><a class="header" href="#check-for-truly-unreachable-code">Check for truly unreachable code.</a></h3>
<p>In some cases, code may be truly unreachable - for example, redundant defensive checks.
Or this may be code which is reachable using particular inputs, but not in the context of your proof.
For example:</p>
<pre><code>int size_from_enum(type_enum t) {
        switch (t) {
        case BAR: return 1;
        case BAZ: return 2;
        ...
}

int function_being_tested() {
        return size_from_enum(BAZ);
}
</code></pre>
<p>In this case, most of the lines in <code>size_from_enum</code> will appear to be unreachable, even though the proof has full coverage of all truly reachable paths.</p>
<h3 id="check-for-over-constrained-inputs"><a class="header" href="#check-for-over-constrained-inputs">Check for over-constrained inputs</a></h3>
<p>Consider the case where one side of a branch is not reached, or where execution does not continue past an assumption.
In this case, it is possible that the inputs have been over-constrained in the proof harness. You can try to relax some of the <code>__CPROVER_assume()</code> statements.</p>
<h2 id="how-can-i-tell-if-my-proof-is-over-constrained"><a class="header" href="#how-can-i-tell-if-my-proof-is-over-constrained">How can I tell if my proof is over-constrained?</a></h2>
<p>This will normally appear in coverage - over-constrained proofs will usually have unreachable portions of code.
You can also add a &quot;smoke test&quot;, but adding assertions that you expect to fail to the code (which can be as simple as <code>assert(0)</code>).
If these assertions do not fail, then something is wrong with your proof.</p>
<h2 id="what-should-i-do-if-cbmc-crashes"><a class="header" href="#what-should-i-do-if-cbmc-crashes">What should I do if CBMC crashes?</a></h2>
<ol>
<li>Make a new branch in your project, containing the exact code that caused cbmc to crash.
We recommend giving it a name like <code>cbmc-crashing-bug-1</code>.</li>
<li>Push it to a public github repo (if possible)</li>
<li>Post a bug report <a href="https://github.com/diffblue/cbmc/issues/new">here</a>, linking to the branch that you pushed containing the bug.</li>
<li>Post a bug report on this repo, linking to the bug that you posted on the main CBMC repo.</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="coding-for-verification"><a class="header" href="#coding-for-verification">Coding for verification</a></h1>
<p>The basic principles of coding for verification are similar to those of coding for testability, with some modifications due to the nature of the SAT solver underlying CBMC.</p>
<h2 id="code-organization-to-support-verification"><a class="header" href="#code-organization-to-support-verification">Code Organization to Support Verification</a></h2>
<ul>
<li>Write small functions. Functions should:
<ul>
<li>Do exactly one thing.</li>
<li>Take all their input and outputs through function parameters and rely as little as possible on global state. Where possible, avoid global variables.</li>
</ul>
</li>
<li>Encapsulate interaction with the environment within a small function. Interaction with the environment includes accessing files, the network, etc. This makes is possible to verify that function independently and then stub it out for the rest of the verification.</li>
<li>Functions should check their input parameters, and return an error code when they fail to verify.
This makes harnesses much simpler, since any value for the parameters is a valid input to the function.</li>
<li>Avoid unbounded loops as far as possible, and encapsulate the ones that you need.  CBMC does bounded model checking, so we need to be able to compute a bound on the number of iterations of any given loop.  Loops that iterate a constant number of times are best.   Loops whose iteration depends on input will require making some assumptions about the input.</li>
<li>Consider defining magic numbers that control loop bounds and buffer sizes in your build system, i.e., <code>-DBUFFER_SIZE=1024</code> and similar. This ensures that you can configure this value at build time, and we can also use those values in our proofs.</li>
<li>Provide an easy way to access static functions and data structures for testing, if you must have them. For example, use a macro that overrides static.</li>
<li>Make threads independently verifiable. When writing concurrent programs, reduce interaction to well-defined points. This enables verification of each thread in isolation.</li>
</ul>
<h2 id="improving-verification-performance"><a class="header" href="#improving-verification-performance">Improving Verification Performance</a></h2>
<ul>
<li>Avoid void pointers (<code>void*</code>). There are two reasons people use void pointers:
<ul>
<li>To hide implementation detail.  This use of void pointers is unnecessary, because we can replace <code>void *bar</code> with <code>struct foo *bar</code> and declare <code>struct foo</code> later within the implementation.</li>
<li>To implement a form of polymorphism.  Don't do this for gratuitous reasons (e.g., because it might someday be useful).  Void pointers can block constant propagation which can dramatically reduce the size of the formula constructed for the constraint solver.</li>
</ul>
</li>
<li>Avoid function pointers. When unavoidable, ensure that function pointer types match a minimum number of candidate functions signatures in your code base (ideally just one). They really can make the difference between a proof and no proof.  When CBMC encounters a function pointer, it has to consider all possibilities for what that function could be, based on loose signature matching.  CBMC has to consider possible any function in the entire program whose address is taken with a signature matching the function pointer.  So for each function invocation, the symbolic execution of a single function is replaced with the symbolic execution of a collection of functions (including the functions they call), and the combinatorial explosion makes the size of the formula too big for memory. The worst thing you can do is to give your functions the signature <code>void foo(void *arg)</code>; see the point above about avoiding <code>void*</code>.</li>
<li>Large (more than several kB in size) arrays can cause trouble. Again, defining the sizes of arrays in the build system means that we can cleanly re-define them to smaller bounds for our proofs.</li>
<li>Data-structures should explicitly carry their size, as a parameter (e.g., Pascal strings are better than C strings).</li>
<li>Stay type safe.
<ul>
<li>Allocate the correct size of objects. Don't allocate less than the correct size for a struct even if you're only using some of its fields.</li>
</ul>
</li>
<li>Consider encapsulating loops in a function, or even just the loop body. Nested loops can lead to a combinatorial explosion in the size of the formula sent to the constraint solver.  Encapsulated loops can be specified and validated in isolation, and the simpler specification can be used in place of the function in the rest of the validation.</li>
<li>Try to minimize string comparisons</li>
<li>E.g., instead of making a <code>string-&gt;string</code> hash table, consider an <code>enum-&gt;string</code> hash-table.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="proof-evaluation"><a class="header" href="#proof-evaluation">Proof evaluation</a></h1>
<p>This is a check list intended for</p>
<ul>
<li>proof writers to use before checking a proof into a repository and</li>
<li>proof reviewers to use during the code review of a pull
request containing a proof.</li>
</ul>
<p>This check list is intended to ensure clear answers to two questions:</p>
<ul>
<li>What properties are being checked by the proof?</li>
<li>What assumptions are being made by the proof?</li>
</ul>
<p>and that these answers can be found in one of three places:</p>
<ul>
<li>The proof harness,</li>
<li>The proof makefiles (and, with the starter kit, these makefiles are
the proof Makefile, the project Makefile-project-defines,
and the project Makefile.common), and perhaps</li>
<li>The proof readme file.</li>
</ul>
<p>The best practices for writing a proof are described
in <a href="management/Write-a-good-proof.html">Write a good proof</a>.
Reviewers should keep these best practices in mind when reading a proof.
We recommend that any deviations from best practices be explained in the
readme file.</p>
<h2 id="properties-checked"><a class="header" href="#properties-checked">Properties checked</a></h2>
<p>Check the following:</p>
<ul>
<li>
<p>All of the standard property-checking flags are used:</p>
<pre><code>  * --bounds-check
  * --conversion-check
  * --div-by-zero-check
  * --float-overflow-check
  * --malloc-fail-null
  * --malloc-may-fail
  * --nan-check
  * --pointer-check
  * --pointer-overflow-check
  * --pointer-primitive-check
  * --signed-overflow-check
  * --undefined-shift-check
  * --unsigned-overflow-check
</code></pre>
<p>Note that the starter kit uses these flags by default.
The properties checked by these flags is documented <a href="http://www.cprover.org/cprover-manual/properties/">on the CPROVER website</a>.
Note, however, that a developer may disable any one of these flags
by editing project Makefile.common or
by setting a makefile variable to the empty string
(as in <code>CBMC_FLAG_MALLOC_MAY_FAIL = </code>)
in the project Makefile-project-defines or a proof Makefile.
These are the places to look for deviations.</p>
</li>
<li>
<p>All deviations from the standard property-checking flags are documented.</p>
<p>There are valid reasons to omit flags either for a project or for an
individual proof. But the decision and the reason for the decision
must be documented either in a project readme or a proof readme file.</p>
</li>
</ul>
<p>CBMC checks assertions in the code.  This is understood and need not be
documented.</p>
<h2 id="assumptions-made"><a class="header" href="#assumptions-made">Assumptions made</a></h2>
<p>Check the following:</p>
<ul>
<li>
<p>All nontrivial data structures have an
<a href="management/Write-a-good-proof.html#the-ensure_allocated-function"><code>ensure_allocated</code> function</a>
as described in the training material.</p>
<p>Feel free to use any naming scheme that makes sense for your project --- some
projects use <code>allocate_X</code> in place of <code>ensure_allocated_X</code> --- but be
consistent.</p>
</li>
<li>
<p>All nontrivial data structures have an
<a href="management/Write-a-good-proof.html#the-is_valid-function"><code>is_valid()</code> predicate</a>
as described in the training material for every nontrivial data structure.</p>
</li>
<li>
<p>All definitions of <code>ensure_allocated</code> functions and <code>is_valid</code> predicates
appear in a common location.</p>
<p>These definitions are most commonly stored in the <code>proofs/sources</code>
subdirectory of the starter kit. Definitions are stored here and used
consistently in the proofs.</p>
</li>
<li>
<p>All pointers passed as input are allocated on the heap with <code>malloc</code>.</p>
<p>One common mistake is to allocate a buffer <code>buf</code> on the stack and to
pass <code>&amp;buf</code> to the function under test in the proof harness.  This prevents
the proof from considering the case of a NULL pointer.</p>
</li>
<li>
<p>All instances of <code>__CPROVER_assume</code> appear in a proof harness.</p>
<p>Note that some exceptions are required.  For example, it may be necessary
in an <code>ensure_allocated</code> to assume <code>length &lt; CBMC_MAX_OBJECT_SIZE</code> before
invoking <code>malloc(length)</code> to avoid a false positive about malloc'ing a
too-big object. But every instance of <code>__CPROVER_assume</code> in supporting code
should be copied into the proof harness.  The goal is for all proof
assumptions to be documented in one place.</p>
</li>
<li>
<p>All preprocessor definitions related to bounds on input size or
otherwise related to proof assumptions appear in the proof Makefile.</p>
<p>In particular, do not embed definitions in the supporting code or header
files. The goal is for all proof assumptions to be documented in one place.</p>
</li>
<li>
<p>Confirm that all stubs used in the proof are acceptable abstractions
of the actual code.</p>
<p>Acceptable could mean simply that every behavior of the original code
is a behavior of the abstraction.</p>
</li>
</ul>
<h2 id="results-checked"><a class="header" href="#results-checked">Results checked</a></h2>
<p>Look at the report in the checks attached to the pull request.</p>
<ul>
<li>
<p>Confirm that the coverage is acceptable and confirm that the readme file
explains the reason for any lines not covered.</p>
</li>
<li>
<p>Confirm that the list of missing functions is acceptable.</p>
</li>
<li>
<p>Confirm that there are no errors reported.</p>
</li>
</ul>
<h2 id="other-things-to-consider"><a class="header" href="#other-things-to-consider">Other things to consider</a></h2>
<ul>
<li>
<p>Consider writing function contracts for the function under test as
described in <a href="management/Write-a-good-proof.html">Write a good proof</a>.
The check list above ensures that the properties (including the
assumptions about the input) that must be true before function
invocation are clearly stated in the proof harness. Consider adding
a statement of what properties must be true after function invocation
as assertions at the end of the proof harness.</p>
</li>
<li>
<p>Consider adding the assumptions made by the proof harness for a
function under test to the source code for the function in the form
of assertions in the code. This will validate that the assumptions made
by the proof of a function are satisfied by each invocation of the function
(at least during testing).</p>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-projects-1"><a class="header" href="#cbmc-projects-1">CBMC projects</a></h1>
<p>Here is a list of software projects that contain some CBMC verification work.</p>
<ul>
<li><a href="https://github.com/awslabs/aws-c-common">AWS C Common</a>
(<a href="https://github.com/awslabs/aws-c-common/tree/main/verification/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/aws-encryption-sdk-c">AWS Encryption SDK for C</a>
(<a href="https://github.com/aws/aws-encryption-sdk-c/tree/master/verification/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/device-defender-for-aws-iot-embedded-sdk">AWS IoT Device Defender Library</a>
(<a href="https://github.com/aws/device-defender-for-aws-iot-embedded-sdk/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/device-shadow-for-aws-iot-embedded-sdk">AWS IoT Device Shadow Library</a>
(<a href="https://github.com/aws/device-shadow-for-aws-iot-embedded-sdk/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/Fleet-Provisioning-for-AWS-IoT-embedded-sdk">AWS IoT Fleet Provisioning Library</a>
(<a href="https://github.com/aws/fleet-provisioning-for-aws-iot-embedded-sdk/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/jobs-for-aws-iot-embedded-sdk">AWS IoT Jobs Library</a>
(<a href="https://github.com/aws/s2n-tls/tree/main/tests/cbmc">cbmc</a>)
(<a href="https://github.com/aws/Jobs-for-AWS-IoT-embedded-sdk/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/ota-for-aws-iot-embedded-sdk">AWS IoT Over-the-air Update Library</a>
(<a href="https://github.com/aws/ota-for-aws-iot-embedded-sdk/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/SigV4-for-AWS-IoT-embedded-sdk">AWS SigV4 Library</a>
(<a href="https://github.com/aws/SigV4-for-AWS-IoT-embedded-sdk/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/s2n-tls">AWS s2n</a>
(<a href="https://github.com/aws/s2n-tls/tree/main/tests/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/aws/amazon-freertos">Amazon FreeRTOS</a>
(<a href="https://github.com/aws/amazon-freertos/tree/main/tools/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/FreeRTOS">FreeRTOS</a>
(<a href="https://github.com/FreeRTOS/FreeRTOS/tree/main/FreeRTOS/Test/CBMC">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/FreeRTOS-Cellular-Interface">FreeRTOS Cellular Interface</a>
(<a href="https://github.com/FreeRTOS/FreeRTOS-Cellular-Interface/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/coreHTTP">FreeRTOS coreHTTP Client Library</a>
(<a href="https://github.com/FreeRTOS/coreHTTP/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/coreJSON">FreeRTOS coreJSON Library</a>
(<a href="https://github.com/FreeRTOS/coreJSON/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/coreMQTT-Agent">FreeRTOS coreMQTT Agent Library</a>
(<a href="https://github.com/FreeRTOS/coreMQTT-Agent/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/coreMQTT">FreeRTOS coreMQTT Client Library</a>
(<a href="https://github.com/FreeRTOS/coreMQTT/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/corePKCS11">FreeRTOS corePCKS11 Library</a>
(<a href="https://github.com/FreeRTOS/corePKCS11/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/coreSNTP">FreeRTOS coreSNTP Library</a>
(<a href="https://github.com/FreeRTOS/coreSNTP/tree/main/test/cbmc">cbmc</a>)</li>
<li><a href="https://github.com/FreeRTOS/FreeRTOS-Plus-TCP">FreeRTOS TCP</a>
(<a href="https://github.com/FreeRTOS/FreeRTOS-Plus-TCP/tree/main/test/cbmc">cbmc</a>)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cbmc-resources"><a class="header" href="#cbmc-resources">CBMC resources</a></h1>
<ul>
<li><a href="https://www.cprover.org/cbmc/">CBMC home page</a></li>
<li><a href="https://github.com/diffblue/cbmc">CBMC github repository</a></li>
<li><a href="resources.html#papers">Papers</a></li>
<li><a href="resources.html#blog-posts">Blog posts</a></li>
<li><a href="resources.html#talks">Talks</a></li>
</ul>
<h2 id="papers"><a class="header" href="#papers">Papers</a></h2>
<h3 id="cbmc-technology"><a class="header" href="#cbmc-technology">CBMC technology</a></h3>
<ul>
<li><a href="http://www.kroening.com/papers/dac2003.pdf">Behavioral Consistency of C and Verilog Programs Using Bounded Model
Checking</a>.
Daniel Kroening, Edmund Clarke, and Karen Yorav.
In <em>Proceedings of Design Automation Conference (DAC)</em>,
pages 368-371, 2003.
<ul>
<li>This is the original paper on CBMC that was later expanded into the
following CMU technical report, which includes a good
description of CBMC's internal architecture:</li>
<li><a href="http://reports-archive.adm.cs.cmu.edu/anon/2003/CMU-CS-03-126.pdf">Behavioral Consistency of C and Verilog Programs</a>.
Edmund Clarke, Daniel Kroening, Karen Yorav.
CMU-CS-03-126, May 2003.</li>
</ul>
</li>
<li>A number of further <a href="https://www.cprover.org/cbmc/applications/">applications of
CBMC</a> can be found online.</li>
</ul>
<h3 id="cbmc-applications"><a class="header" href="#cbmc-applications">CBMC applications</a></h3>
<ul>
<li>
<p><a href="https://link.springer.com/article/10.1007/s10703-020-00344-2">Model checking boot code from AWS data centers</a>.
Byron Cook,
Kareem Khazem,
Daniel Kroening,
Serdar Tasiran,
Michael
Tautschnig,
Mark R. Tuttle.
<em>Formal Methods in System Design</em>, volume 57, number 1, pages 34-52,
July 2021.</p>
<ul>
<li>This paper originally appeared in the following paper at CAV 2018:</li>
<li><a href="https://link.springer.com/chapter/10.1007/978-3-319-96142-2_28">Model Checking Boot Code from AWS Data Centers</a>.
Byron Cook,
Kareem Khazem,
Daniel Kroening,
Serdar Tasiran,
Michael
Tautschnig,
Mark R. Tuttle:
In <em>Proceedings of the 30th International Conference on Computer
Aided Verification</em> (CAV 2018), pages 267-486, July 2018.</li>
</ul>
</li>
<li>
<p><a href="https://onlinelibrary.wiley.com/doi/epdf/10.1002/spe.2949">Code-level model checking in the software development workflow at
Amazon Web Services</a>.
Nathan Chong,
Byron Cook,
Jonathan Eidelman,
Konstantinos Kallas,
Kareem Khazem,
Felipe R. Monteiro,
Daniel Schwartz-Narbonne,
Serdar
Tasiran,
Michael Tautschnig,
Mark R. Tuttle.
<em>Journal of Software: Practice and Experience --- Special Issue:
Introduction to the Special Issue on Software Engineering in
Practice</em>, volume 51, issue 4, pages 772-797, April 2021.</p>
<ul>
<li>This paper originally appears in the following paper at ICSE 2020:</li>
<li><a href="https://dl.acm.org/doi/pdf/10.1145/3377813.3381347">Code-Level Model Checking in the Software Development Workflow</a>.
Nathan Chong,
Byron Cook,
Konstantinos Kallas,
Kareem Khazem,
Felipe R. Monteiro,
Daniel Schwartz-Narbonne,
Serdar Tasiran,
Michael Tautschnig,  and
Mark R. Tuttle.
In <em>Proceedings of the ACM/IEEE 42nd International Conference on
Software Engineering: Software Engineering in Practice</em> (ICSE-SEIP 2020),
pages 11–20, June 2020.</li>
</ul>
</li>
</ul>
<h2 id="blog-posts"><a class="header" href="#blog-posts">Blog posts</a></h2>
<ul>
<li>
<p><a href="https://aws.amazon.com/blogs/security/automated-reasoning-provable-security-of-boot-code-tlarg/">Daniel Schwartz-Narbonne shares how automated reasoning is helping
achieve the provable security of AWS boot code</a>
in the <a href="https://aws.amazon.com/blogs/security/">AWS Security Blog</a>.
Supriya Anand. October 2, 2018.</p>
</li>
<li>
<p><a href="https://www.freertos.org/2020/02/ensuring-the-memory-safety-of-freertos-part-1.html">Ensuring the Memory Safety of FreeRTOS Part 1</a> and
<a href="https://www.freertos.org/2020/05/ensuring-the-memory-safety-of-freertos-part-2.html">Part 2</a> in the
<a href="https://www.freertos.org/blog.html">FreeRTOS Blog</a>.
Nathan Chong, February and May 2020.</p>
</li>
</ul>
<h2 id="talks"><a class="header" href="#talks">Talks</a></h2>
<ul>
<li><a href="https://www.youtube.com/watch?v=-EuIrAP9_tU">Code-level model checking in the software development workflow</a>, Daniel Schwartz-Narbonne,
ICSE 2020 conference talk.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
